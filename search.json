[{"title":"浅学软件工程","url":"/2023/10/27/%E6%B5%85%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","content":" 浅学软件工程\n 三、软件过程模型\n 什么是软件过程模型？\n软件过程模型是一种软件过程的抽象表示法。\n软件过程模型是对软件开发的复杂过程的抽象描述，是从一个特定的角度表现一个过程一般使用直观的图形来表示软件开发的复杂过程。\n 传统的软件过程模型\n 瀑布模型\n\n应用最广泛的过程模型。\n\n瀑布模型是将软件生存周期的各项活动规定为按固定顺序（线性）而连接的若干阶段工作，最终得到软件产品。\n因过程形如瀑布，因此得名瀑布模型。\n \n特点：\n\n顺序性和依赖性\n推迟实现\n质量保证\n\n 增量模型\n**增量模型（incremental mode）**也称为渐增模型，是在项目的开发过程中以一系列的增量方式开发系统。\n把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件。\n运用增量模型的软件开发过程是递增式的过程。\n相对于瀑布模型，采用增量模型进行开发，开发人员不需要一次性地把整个软件产品提交给用户，而是分批次地进行提交。\n 螺旋模型\n**螺旋模型（spiral model）**是由Barry Boehm正式提出的模型，它将瀑布模型和快速原型模型结合起来，不仅体现了两个模型的优点，而且还强调了其他模型均忽略的风险分析，特别适合于大型复杂的系统。\n螺旋模型采用一种周期性的方法来进行系统开发。这会导致开发出众多的中间版本。项目经理在早期就能够为客户证实某些概念。该模型是快速原型法，以进化的开发方式为中心，在每个项目阶段使用瀑布模型。\n这种模型的每一个周期都包括需求定义、风险分析、工程实现和评审4个阶段，由这4个阶段进行迭代。\n\n 面向对象模型\n 构件集成模型\n构件集成模型利用模块化方法将整个系统模块化，并在一定构建模型的支持下重用构件库中的软件构件，通过组合手段提高应用软件系统过程的效率和质量。\n构件集成模型融合螺旋模型的许多特征，本质上是演化型的，开发过程是迭代的。\n 统一过程模型\n统一过程模型（Unified Process，UP）是风险驱动的、基于用例技术的、以架构为中心的、迭代的、可配置的软件开发流程。\nUP是一个面向对象且基于网络的程序开发方法论。它可以为所有方面和层次的程序开发提供指导方针、模板以及用例支持。\n统一过程模型是在重复一系列组成系统生存周期的循环。每一次循环包括4个阶段：初始、细化、构造和移交，每个阶段又进一步细分为多次迭代的过程，每次循环迭代会产生一个新的版本，每个版本都是一个准备交付的产品。\n\n 四、敏捷软件开发方法\n\nAgile Software Development（敏捷软件开发）\n\n 什么是敏捷（Agile）？\n敏捷是一种通过创造变化和响应变化在不确定和混乱的环境中取得成功的能力。\n敏捷开发是一种应对快速变化的需求的一种软件开发能力。\n敏捷是一个描述软件开发方法的术语，它强调增量交付、团队协作、持续规划和持续学习。\n敏捷这个术语是2001年在敏捷宣言中提出的。\n 敏捷宣言\n\n我们应重视：\n\n个体和交互胜过流程和工具。\n有效用的软件胜过全面的文档。\n客户协作胜过合同协商。\n响应变化胜过遵循计划。\n\n\n在发表《敏捷宣言》之前，很多敏捷实践已经存在并使用了，例如：Scrum、XP、KanBan等。\n发表《敏捷宣言》之后，有了统一的指导方针，形成了联合体的形式。\n 什么是敏捷软件开发（Agile Software Development）？\n敏捷软件开发是基于敏捷宣言定义的价值观和原则的一系列方法和实践的总称。自组织、跨职能团队运用适合他们自身环境的实践进行演进得出解决方案。\n敏捷不是指某一种具体的方法论、过程或框架，而是一组价值观和原则。\n符合敏捷价值观和原则的开发方法包括：\n\n极限编程（XP）\nScrum\n精益软件开发（Lean Software Development）\n动态系统开发方法（DSDM）\n特征驱动开发（Feature Driver Development）\n水晶开发（Crystal Clear）\n\n 敏捷软件开发过程\n\n需求计划：确定项目目标和需求\n迭代规划：小步快跑的实现过程\n计划冲刺：确定冲刺目标和任务\n日常站会：保持沟通与协作\n迭代审查：展示交付成果并获得反馈\n迭代回顾：持续改进的机会\n\n Scrum开发过程\n 定义与目的\nScrum本指橄榄球运动中的“争球”的动作——团队通力合作，在场地内传球。\n以Scrum命名，目的是让开发人员像打橄榄球一样迅猛并充满激情，通过团队合作，提高工作效率。\nScrum就是以交付 和迭代为核心的方法。\n每过一小段时间就停下工作，检查一下已经完成了哪些任务，这些任务是不是应该自己做的，思考有没有更好的方法。\n 三个角色\nScrum中的人员分为3个角色：产品所有者（Product Owner）, Scrum Master，开发团队(Team)。\n\n产品所有者：定义所有产品功能，决定产品发布的内容以及日期，对产品的投入产出负责，根据市场变化对需要开发的功能排列优先顺序，合理地调整产品功能和迭代顺序，认同或者拒绝迭代的交付。\nScrumMaster ：ScrumMaster不是项目经理，他没有分配任务的权力，没有考核的权力，没有下命令的权力，他指导项目组的成员按照Scrum的原则、方法做事情，领导团队完成Scrum的实践以及体现其价值，排除团队遇到的困难，确保团队胜任其工作，并保持高效的生产率，使得团队紧密合作，使得团队个人具有多方面职能的工作能力，保护团队不受到外来无端影响。\n开发团队：经典团队拥有 5-9 人，团队成员包含程序员、测试员、用户体验设计等等，团队关系在一个迭代中应该是固定的，个人的职能可以在新迭代开始时发生调整，团队自我组织和管理（自组织，自驱动），团队成员都全职工作。\n\n 五个会议\nScrum 整个开发过程分为五个会议:\n\n待办事项整理会议（Backlog Grooming Meeting）\n\n迭代计划会议开始之前3天召开，Product Owner与Scrum Master必须参加，关键开发者或架构师需要参加；时间控制在30分钟到1小时。\n\n迭代计划会议（Sprint Planning Meeting）\n\n产品负责人建立产品功能列表（Product Backlog）。产品功能列表是一组条目化需求，它必须从客户价值角度描述，并按优先级排序。\nScrum Master召集相关人员召开迭代计划会，迭代计划会在每个迭代第一天召开，目的是选择本次迭代的Backlog和估算本次迭代的工作量。\n\n每日站会（Standup Meeting）\n\n团队内部利用每日立会来沟通进度，15分钟结束，开发团队利用燃尽图来展示整体进度；如无特殊原因，迭代期内无变更，在每日站会上团队成员需要回答以下3个问题：\n\n昨天你做了什么?\n今天你将要做什么?\n你有需要帮助的地方吗?\n\n这些都是团队成员的彼此承诺。\n\n评审会（Retrospective Meeting）\n\n小组向产品负责人展示迭代工作结果，产品负责人给出评价和反馈。以用户故事是否能成功交付来评价任务完成情况。整个团队都需要参加，ScrumMaster、产品所有者、团队，可能还有客户，时间控制在1-2小时内。\n\n反思会（Retrospective Meeting）\n\n在每个迭代后召开简短的反思会，总结哪些事情做得好，哪些事情做得不好。做得好的保留，不好的摒弃。会议得出这样的结论：开始做什么、继续做什么、停止做什么，一般控制在15-30分钟。\n 十二原则\n这十二原则作为敏捷开发对于软件开发流程的指导性纲领，也是对敏捷宣言进行了具有实际操作意义的解释。\n我们遵循以下准则：\n\n我们的最高目标是，通过尽早和持续地交付有价值的软件来满足客户。\n欢迎对需求提出变更——即使是在项目开发后期。要善于利用需求变更，帮助客户获得竞争优势。\n要不断交付可用的软件，周期从几周到几个月不等，且越短越好。\n项目过程中，业务人员与开发人员必须在一起工作。\n要善于激励项目人员，给他们以所需要的环境和支持，并相信他们能够完成任务。\n无论是团队内还是团队间，最有效的沟通方法是面对面的交谈。\n可用的软件是衡量进度的主要指标。\n敏捷过程提倡可持续的开发。项目方、开发人员和用户应该能够保持恒久稳定的进展速度。\n对技术的精益求精以及对设计的不断完善将提升敏捷性。\n要做到简洁，即尽最大可能减少不必要的工作。这是一门艺术。\n最佳的架构、需求和设计出自于自组织的团队。\n团队要定期反省如何能够做到更有效，并相应地调整团队的行为\n\n 极限编程\n极限编程是一种敏捷软件开发方法，它强调快速反馈、持续集成、测试驱动开发、简单设计和重构等实践。\n极限编程的目标是提高软件开发的质量和效率，同时降低开发成本和风险。\n极限编程是第一批敏捷开发方法中最具实效的一种。在各种敏捷方法中，极限编程最为重视工程实践。\n在极限编程中，开发人员需要遵循以下实践：\n\n快速反馈：团队成员理解客户在开发过程中给出的反馈，并能够迅速做出反应。\n假设简单：开发人员需要专注于当前重要的工作，遵循所有问题都可以简单地解决原则。\n增量变化：对产品一小步一小步的改变比一次性的大改变效果更好。\n拥抱变化：如果客户认为产品需要改变，作为程序员，他们应该支持这个决定，并拟定如何实现新需求的计划。\n高质量的工作：一个工作出色的团队，他们能够创造出有价值的产品，并为此感到自豪。\n\n 五个价值\n\n沟通：团队中的每个人都互通工作。\n简单性：开发人员努力编写简单的代码，为产品带来更多价值，因为这样可以节省时间和精力。\n反馈：团队成员经常交付软件，获取有关软件的反馈，并根据新的需求改进产品。\n尊重：每个被分配到项目中的人都为一个共同的目标做出贡献。\n勇气：成员客观地评估自己的失误造成的后果而不是找借口，并且随时准备应对变化。\n\n XP和Scrum的核心区别\nXP 更关注技术和工程实践，而 Scrum 更关注团队协作和管理实践。\n 结对编程\n\n设计和编程都是人的活动。忘记这一点，将会失去一切。——Bjarne Stroustrup\n\n 什么是结对编程？\n结对编程（Pair programming）来自于极限编程(eXtreme Programming)。\n顾名思义，结对编程就是由两个程序员用同一台电脑完成同一个任务，由一个人负责编写代码，另一个负责审查代码，从而能够时时刻刻的进行代码评审。\n 结对编程的优点\n从项目角度，提高了产品质量\n结对编程时，两个人共同完成一个功能，可以避免个人的误区存在，通常个人的想法难免有局限性，自己看自己写的代码总是觉得怎么都对。每个人站在不同的角度能够看到彼此的误差。\n从团队角度，更好的实现了知识传递和分享，让成员关系更融洽\n不可否认，结对这种面对面的沟通交流方式，对于知识和技能的传递是最好的形式。同时，这种即时的沟通交流也让同事之间关系变得融洽，相对比那种每个人一个格子间闷头写代码，更利于创建和谐的团队氛围。\n培养新人，促进沟通，提升团队整体能力。\n通过结对，年轻的团队成员可以向其他小伙伴学习，包括快捷键、算法、语法、SQL、设计、解决问题的思路、做事方式等等，1对1面对面师傅带徒弟式的学习是新技能get最快的方式之一。\n 五、软件需求分析\n在软件开发前，进行有效的软件需求分析是非常重要的。\n通过深入了解需求，可以防止项目在后续不断扩大，导致预算超支或项目延期，也能确保软件在实际使用中能够满足用户期望，提高用户满意度。\n 可行性分析\n 什么是可行性分析\n检查并确定是否值得为项目或产品投入时间、金钱和资源。\n这样的评估活动称为“可行性分析”。\n 为什么要进行可行性分析\n在软件项目开发过程中，只要资源和时间不受限制，几乎所有项目都是可行的。\n然而由于受到资源和交付时间的限制，使得软件系统的开发变得越来越困难。因此尽早对软件项目的可行性进行细致而谨慎的分析是十分必要的。\n进行可行性分析才能明确系统是否值得做，避免投资损失，能否带来经济效益、企业效益或社会效益。\n 可行性分析的主要任务是什么\n可行性分析的目的不是解决问题，而是确定问题是否可解并且是否值得去解决。\n 可行性分析的主要过程\n\n检查系统规模和目标，明确限制或约束条件\n研究正在使用的系统\n导出新系统的高层次逻辑模型\n提出可行性解决方案并评估比较\n选择合适的解决方案\n撰写可行性分析报告并提交审查\n\n可行性分析主要集中在以下四个方面：\n\n\n经济可行性分析\n\n\n技术可行性分析\n\n\n法律可行性分析\n\n\n实施方案的选择\n\n\n 经济可行性分析\n软件开发需要有投资，有投资就需要有收益。\n经济可行性分析的目的是从经济角度评价一个新项目是否可行、是否划算，帮助投资人或用户正确投资。\n 技术可行性分析\n主要考虑：\n\n开发风险：在给定的限制范围内，能否设计出系统并实现必要的功能和性能。\n资源可用性：是否有充足的技术人员可以支配。\n技术条件：相关的技术条件是否能够支持系统的开发。\n\n 法律可行性分析\n开发的软件项目是否会触犯法律法规\n 什么是软件需求\n软件需求分析是软件开发过程中的首要步骤，它旨在收集、理解和明确定义软件系统的需求和目标。\n软件需求包括4个不同的层次：\n\n**业务需求：**反映了组织结构或客户对系统、产品高层次的目标要求，它们在项目视图与范围文档中予以说明。\n用户需求：站在用户的角度描述软件产品必须要完成的业务功能，这在使用实例文档或场景说明中予以详细描述。\n功能需求：站在开发人员的角度定义了必须实现的软件功能，使得用户能完成他们的任务，从而满足了业务需求。\n非功能需求：指逻辑上与软件相关的整体特性需求的集合，给用户提供处理能力并满足业务需求。\n\n非功能需求可分为：\n\n产品需求：描述产品行为的需求，包括系统运行速度和内存消耗等性能需求、出错率等可靠性需求和可用性需求。\n机构需求：客户和开发者所在机构中的政策和规定要求。\n外部需求：包括所有的系统外部因素和开发过程。\n\n 需求分析过程\n需求分析主要是理解客户需要什么、分析要求、评价可行性、协商合理的方案、无歧义地详细说明方案、确认规格说明、管理需求以至将这些需求转化为可行系统。\n 沟通\n当确定了商业需求或发现了潜在的新市场时开始。\n在项目起始阶段，软件工程师会询问一些似乎与项目无直接关系的问题，目的是对问题、方案需求方、客户和开发人员之间初步的交流和合作的效果建立基本的协商准备。\n 导出需求\n确定系统范围：系统的范围就是系统的边界，是客户和开发者共同关心的部分。\n理解客户需要：客户/用户并不完全确定需要什么，系统工程师的任务是确定业务需求、需求冲突，说明有歧义和不可测试的需求。\n易变问题：由于各种原因如客户讲不清楚、业务发生变化等，需求随时间变化。\n识别真正的客户与用户：识别真正的客户不是一件容易的事情，项目要面对多方的客户，有时他们的利益各不相同给。\n正确理解客户的需求：客户可能会说出客户不需要的、模糊、混乱矛盾的信息，甚至可能夸大或弱化真正的需求。\n耐心听取客户意见：获取需求应能够从客户凌乱的建议和观点整理出真正的需求，耐心分析客户不确定性需求和过分需求，并进行沟通。\n尽量使用符合客户语言习惯的表达：使用符合客户熟悉的术语进行交流。\n 精化需求\n开发一个精确的技术模型，用以说明软件的功能、特征和约束。\n精化是一个分析建模动作，由一系列建模和求精任务构成。\n精化的结果是形成一个分析模型，该模型定义了问题的信息域、功能域和行为域。\n 可行性研究\n可行性研究的目的是确定用最小的代价，在尽可能短的时间内确定问题是否能够解决。\n从技术可行性、经济可行性、管理可行性和时间可行性4个方面研究每种方案的可行性。\n 与客户和用户协商\n用户和客户提出了过高的目标要求，或者提出了相互冲突的要求，这就需要工程师通过协商和沟通的过程来调节这些冲突和问题。\n 编写需求规格说明\n一个规格说明可以是一份写好的文档、一套图形化的模型、一个形式化的数学模型、一组使用场景、一个原型或以上各项的任意组合。\n对于大型系统而言，文档最好采用自然语言描述（人话）和图形化模型来编写。\n软件需求规格（Software Requirement Sepcification, SRS）是需求分析任务的最终“产品”，是客户、管理者、分析工程师、测试工程师、维护工程师交流的标准和依据。SRS说明文档描述了系统的数据、功能、行为、性能需求、设计约束、验收标准以及其他与需求相关的信息。\n计算机软件需求规格说明规范现行标准：国家标准|GB/T 9385-2008 (samr.gov.cn)\n 验证需求\n验证需求包括正确性、一致性、完整性、可行性、必要性、可检验性、可跟踪性及最后的签字确认。\n 管理需求\n管理需求是对需求进行组织、控制和文档化的系统方法。\n 会谈技术\n 非正式会谈\n非正式会谈将提出一些可自由回答的问题来鼓励会谈人员表达自己的想法。\n非正式会谈一般从其他话题入手，建立融洽的氛围后，才开始转到项目的事情上来。\n一般2~4个小时。\n 正式会谈\n正式会谈将提出一些事先准备号的议题。\n会谈者要准备一份有关会谈结果概要的书面报告，以便进一步陈述或者增加忽略的项目。\n 调查技术\n获得需求的另外一种方法是向客户组织的相关人员发调查表。\n 确定调查内容\n当需要对数百人进行个人意见调查时，调查技术十分有效。\n先于主要的用户进行非正式会谈。在对此次会谈理解的基础上制定调查表，分发给所有客户组织人员。\n 可靠可信分析\n虽然问卷调查对于有大量用户的项目而言是一个非常好的方法。然而由于问卷题目设置不当或者题目内容的不合理，也会导致得出错误的结论。\n因此，需要根据问卷调查结果进行问卷可靠可信分析。\n可靠可信分析的目的是检查问卷的指标设置是否合理，指标之间是否存在关联，以及结果是否可信等。\n进行可靠可信分析的基本方法是层次分析法。\n 场景分析技术\n若能把人与一个软件系统交互的过程用一个场景来描述，人们就容易理解并评论它。\n需求分析从对场景的评论中得到信息，然后将其以形式化方式表示出来。这种方法称为场景分析，或情景分析。\n场景开始于一个框架，在导出过程中，细节被逐渐增加，指导产生交互的一个完整的描述。\n绝大多数情况，一个场景可能包括如下内容：\n\n在场景开始部分有一个系统状态描述\n一个关于标准事件流的描述\n一个关于哪儿会出错，以及如果处理错误的描述\n有关其他可能在同一时间进行的活动的信息\n在场景完成后系统状态的描述\n\n\n 六、结构化分析\n\n结构化分析（Structured Analysis，SA）方法是一种传统的系统建模技术，其过程是创建描述信息内容和数据流的模型，依据功能和行为对系统进行划分，并描述必须建立的系统要素。\n\n结构化分析方法一般采用以下指导性原则：\n\n理解问题\n开发模型\n描述需求\n建立系统模型\n确定需求优先级\n验证需求\n\n 结构化分析模型\n\n结构化分析方法是一种半形式化的建模技术，其过程是对系统信息进行分析，抽取其本质要素，创建描述数据和行为的模型。\n\n结构化分析模型必须分别达到以下主要目标：描述客户需求，建立软件设计的基础，定义在软件完成后可以确认的一组需求。\n面向数据的模型主要刻画软件中所涉及的数据及其关系，用来确定系统的数据结构和存储模型。\n面向系统行为的模型包括两种类型模型：\n\n数据流模型：用来描述系统中的数据处理过程。\n状态转化模型：用来描述系统如何对事件做出响应。\n\n结构化分析模型分别用**数据字典（Data Dictionary，DD）、数据流图（Data Flow Diagram，DFD）、状态转换图（State Transition Diagram，STD）、实体关系图（Entity Relationship Diagram，ERD）**等描述。\n\n分析模型结构的核心是数据字典，包含了软件使用或生产的所有数据对象描述的中心库）。\n\n 面向数据流的建模方法\n\n结构化分析是面向数据流进行需求分析的方法，是一种建模活动。\n\n 数据流图（待详细）\n\n期末可能考给案例画数据流图\n\n\n用数据流图描述系统处理过程是一种很直观的方式。\n数据流图的基本要点是描绘“做什么”，而不考虑“怎么做”。\n 数据字典\n\nData Dictionary, DD\n\n数据字典是对数据流图中包含的所有元素的定义的集合，是分析模型中出现的所有名字的一个集合，并包括有关命名实体的描述。\n 符号\n\n\n\n符号\n含义\n说明\n\n\n\n\n=\n被定义为\n姓名 = 10字符\n\n\n+\n与\nx = a + b，x由a和b组成\n\n\n[…|…]\n或\nx = [a|b]，x由a或b组成\n\n\nm{…}n或{…}mn^n _mmn​\n重复\nx = 1{b}5或x = {b}15^5_115​，表示x中最少出现1次b，最多5次，m下限，n上限\n\n\n(…)\n可选\nx = (a) 表示a可在x中出现，也可不出现\n\n\n…\n连接符\nx = 0…9，x可取0~9中任意一个符。\n\n\n\n 数据流条目\n列出该数据流的各组成数据项\n数据流的组成成员是数据项，数据项条目是不可再分解的数据单位。\n例：\n\n名字：订货报表\n别名：订货信息\n描述：每天一次需要订货的零件表\n定义：订货报表=零件编号+零件名称+订货数量+价格+1{供应者}3\n位置：输出到打印机\n​\t\t\t零件编号=8位字符\n​\t\t\t零件名称=20位字符\n​\t\t\t订货数量=[1|2|3|4|5]\n​\t\t\t价格={零件单价}\n​\t\t\t供应者=24位字符\n\n这种数据字典卡片主要包含：名字、别名、描述、定义、位置\n 七、结构化设计\n\n设计：一种软件开发活动，定义实现需要规约所需的软件结构\n\n设计的目标：\n\n依据需求规约在一个抽象层上建立系统软件模型，包括软件体系结构（数据和程序结构），以及详细的处理算法。\n给出软件解决方案，产生设计规格说明书。\n\n结构化设计分为：\n\n总体设计：确定系统的整体模块结构（系统实现所需要的软件模块以及这些模块之间的调用关系）。\n详细设计：详细描述模块。\n\n 整体框架\n\n\n\n体系结构设计（MSD）：定义软件模块及其之间的关系，从分析模型（如数据流图）导出。\n\n\n接口设计：\n外部接口设计：根据分析模型中的顶层数据流图得到，包括用户界面、目标系统与其他硬件设备、软件系统的外部接口\n内部接口设计：系统内部各种元素间的接口\n\n\n数据设计：根据数据字典确定软件涉及的文件系统的结构及数据库的表结构\n\n\n 模块化设计\n\n分而治之\n\n 基本概念\n精化：基于模块化原理“高内聚，低耦合”将初始的MSD转化为最终可详细设计使用的MSD。\n模块：执行一个特殊任务的一组程序和数据结构。\n模块化：把系统分解成若干模块的过程，使得程序能够被理性的管理。\n 高内聚 低耦合\n\n内聚：一个模块之内各成分之间相互依赖程度的度量。\n耦合：不同模块间相互依赖程度的度量。\n\n英：\n\n高内聚：High Cohesion; Strong cohesion; Maximize Cohesion\ncohesion  美 [koʊˈhiʒ(ə)n] n.内聚力；结合；凝聚性；黏合\n低耦合：Low Coupling; loosely coupled; Minimize Coupling\ncoupling  美 [ˈkʌp(ə)lɪŋ] n.联轴器；连接；联结；结合\n\n 内聚类型（由低到高）\n\n偶然内聚：一个模块之内各成分之间没有任何关系。\n逻辑内聚：几个逻辑上相关的功能放在同一模块中。\n时间内聚：一个模块完成的功能必须在同一时间内完成，而这些功能只是因为时间因素关联在一起。\n过程内聚：处理成分必须以特定的次序执行。\n通信内聚：各成分都操作在同一数据集或生成同一数据集。\n顺序内聚：各成分与一个功能相关，且一个成分的输出作为另一成分的输入。\n功能内聚：模块的所有成分对完成单一功能是最基本的，且该模块对完成这一功能而言是充分必要的。\n\n 耦合类型（由高到低）\n\n内容耦合：一个模块直接修改或操作另一个模块的数据。\n公共耦合：两个及以上的模块共引用一个全局数据项。\n控制耦合：一个模块向另一个模块传递控制信号。\n标记耦合：两个模块至少有一个通过界面传递的公共参数，包含内部数据，如数组，字符串等。\n数据耦合：模块间通过参数传递基本类型的数据。\n\n耦合的强度所依赖的因素：\n\n模块间的引用\n模块间传递的数据量\n模块间的施加控制量\n模块间接口复杂度\n\n 软件结构图\n\n结构图（Structure Chart，SC）是精确表达软件结构的图形表示方法，它以特定的符号表示模块、模块间的调用关系和模块间信息的传递。\n\n 主要构成\n\n模块（Module）：用矩形框表示，框内为模块名，说明模块功能。\n调用：用箭头表示，一般是上层调用下层。\n数据：调用点头旁的短箭头表示调用时从一个模块传给另一个模块的数据。短箭头旁注有信息名字，常用尾端带有空心圆的短箭头表示数据信息，用尾端带有实心圆的短箭头表示控制信息。\n条件符号：当模块A有条件的调用模块B时，在模块A的调用箭头尾部标以菱形符号。\n循环符号：当模块A反复的调用其他模块时，在调用箭头尾部标以弧形符号。\n\n 软件体系结构模型\n 体系结构模式\n","categories":["笔记"],"tags":["软件工程"]},{"title":"浅学编译原理","url":"/2023/10/27/%E6%B5%85%E5%AD%A6%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","content":" 浅学编译原理\n\n为考试而学——CS课程的悲哀\n\n教材字多，懒的看\n 语言和语法\n 基本术语及概念\n 字母表和符号\n 符号：语言中不可再分的单位\n例如：\n\n汉字的字母表：汉字、数字和标点符号等。\n英文的字母表：{a,b,…,z , A,b,…,Z}。\n二进制的字母表：{0,1}。\n标识符的字母表：{a,b,…,z , A,b,…,Z , 0…9 , _ }。\n\n 字母表：符号的非空有穷集合\n∑={x∣x∈ASCII}\\sum= \\{ x |x\\in ASCII \\}∑={x∣x∈ASCII}\nV1={a,b,c}V_1 = \\{ a,b,c\\}V1​={a,b,c}\n\n 符号串\n某个字母表上的符号的有穷集合\nV1：a,b,c,ab,bc,ac,abc,...V_1 ：a,b,c,ab,bc, ac,abc,...V1​：a,b,c,ab,bc,ac,abc,...\nV2:123,+12,−2,...V_2: 123,+12,-2,...V2​:123,+12,−2,...\n空串（ε）：不含任何符号的串\n 语句\n字符表上符号某种构成规则的符号串序列\n用a, b, c,…表示符号\n用α,β,γ,...\\alpha,\\beta,\\gamma,...α,β,γ,...表示符号串\n用A, B, C, …表示符号或符号串的集合\n 语言\n某个字母表上的句子集合\n 符号串集合的积\n若A={a,b},B={c,e,d},A = \\{a,b\\}, B = \\{c,e,d\\},A={a,b},B={c,e,d},则AB={ac,ae,ad,bc,be,bd}AB = \\{ac,ae,ad,bc,be,bd\\}AB={ac,ae,ad,bc,be,bd}\n即二者的笛卡尔积AB={αβ∣α∈A,β∈B}AB=\\{ \\alpha \\beta |\\alpha \\in A,\\beta \\in B \\}AB={αβ∣α∈A,β∈B}\n 字符串集合的幂\nA0={ϵ}A^0 = \\{\\epsilon \\}A0={ϵ}，空串ϵ\\epsilonϵ\nAn={AAn−1}A^n = \\{AA^{n-1} \\}An={AAn−1}\n若∣A∣=m,|A| = m,∣A∣=m,则，∣A0∣=1,∣A1∣=m,∣Am∣=mn|A^0| = 1, |A^1|=m,|A^m| = m^n∣A0∣=1,∣A1∣=m,∣Am∣=mn\n 闭包和正闭包\n闭包：A∗=A0∪A1∪A2∪...A^* = A^0 \\cup A^1 \\cup A^2 \\cup ...A∗=A0∪A1∪A2∪...\n正闭包：A+=A∗−{ϵ}A^+ = A^* - \\{\\epsilon \\}A+=A∗−{ϵ}，正闭包就是不包含空串\n一个语言是其字母表上闭包的子集\n 文法\n表达语言构成规则的形式化方法：G=VN,VT,S,PG = {V_N,V_T,S,P}G=VN​,VT​,S,P\n下面有更详细的介绍。\n 推导与规约\n推导：使用产生式的右部替代左部的过程\n归纳：推导的逆过程，即用产生式的左部替换右部的过程\n 句型、句子和语言\n句型：从文法开始符号S开始，每步推导（包括0步）所得到的字符串α,S→α\\alpha,S → \\alphaα,S→α,其中α∈(VN,VT)∗\\alpha \\in (V_N,V_T)^*α∈(VN​,VT​)∗\n句子：仅含终结符的句型\n语言：由S推导得到的句子集合\nL(G)={α∣S→α,且α∈VT∗},GL(G) = \\{\\alpha | S → \\alpha,且\\alpha \\in V_T ^* \\},GL(G)={α∣S→α,且α∈VT∗​},G为文法。\n 文法递归\n非终结符的定义中包含了非终结符自身\n∑={0,1}\\sum = \\{0,1 \\}∑={0,1}\n&lt;S&gt;→&lt;D&gt;&lt;S&gt;&lt;D&gt;&lt;S&gt; → &lt;D&gt;&lt;S&gt;&lt;D&gt;&lt;S&gt;→&lt;D&gt;&lt;S&gt;&lt;D&gt;\n&lt;D&gt;→0∣1&lt;D&gt; → 0|1&lt;D&gt;→0∣1\n BNF范式\n巴科斯范式（BNF）所描述的语法是与上下文无关的。\n ( )：提出因子\nU→ax∣ay∣azU → ax|ay|azU→ax∣ay∣az 可写成 U→a(x∣y∣z)U → a(x|y|z)U→a(x∣y∣z)\n { }：指定重复次数\n&lt;标识符&gt;→&lt;字母&gt;{&lt;字母&gt;∣&lt;数字&gt;}(0)(3)&lt;标识符&gt; →&lt;字母&gt;\\{&lt;字母&gt;|&lt;数字&gt;\\}^{(3)}_{(0)}&lt;标识符&gt;→&lt;字母&gt;{&lt;字母&gt;∣&lt;数字&gt;}(0)(3)​\n [ ]：任选符号\n&lt;数字&gt;→[+∣−]&lt;数字&gt;{&lt;数字&gt;}&lt;数字&gt; → [+|-]&lt;数字&gt;\\{&lt;数字&gt;\\}&lt;数字&gt;→[+∣−]&lt;数字&gt;{&lt;数字&gt;}\n 文法和语言的形式定义\n 文法的直观概念\n文法是对语言结构的定义与描述。\n即从形式上用于描述和规定语言结构的成为“文法”（语法）。\n所谓文法是在形式上对句子结构的定义与描述，而未涉及语义问题。\n“形式”是指：语言的所有规则只以什么符号串能出现的方式来陈述。\n 语法规则\n规定用 ::=表示 由...组成。\n例如：\n&lt;句子&gt; ::= &lt;主语&gt;&lt;谓语&gt;&lt;主语&gt; ::= &lt;代词&gt;|&lt;名词&gt;&lt;代词&gt;  ::= 你|我|他&lt;名词&gt; ::= 王民|大学生|工人|英语&lt;谓语&gt; ::= &lt;动词&gt;&lt;直接宾语&gt;&lt;动词&gt; ::= 是|学习&lt;直接宾语&gt;::=&lt;代词&gt;|&lt;名词&gt;\n 规则\n规则（重写规则、产生式、生成式）是形如 α→β\\alpha → \\betaα→β或α::=β\\alpha ::= \\betaα::=β的(α,β)(\\alpha,\\beta)(α,β)的有序对。\n其中α∈V+,β∈V∗\\alpha \\in V^+,\\beta \\in V^*α∈V+,β∈V∗\n\nα\\alphaα称为规则的左部\nβ\\betaβ称为规则的右部\n\n例如：\n&lt;程序&gt; → &lt;分程序&gt;\n&lt;条件语句&gt; → IF&lt;条件&gt;THEN&lt;语句&gt;\n 文法的定义\n文法G定义为四元组(VN,VT,P,S)(V_N,V_T,P,S)(VN​,VT​,P,S)\n\nVNV_NVN​：非终结符集\n\n**非终结符(nonterminal)**是用来表示语法成分的符号，有时也成为“语法变量”\n例：VN={&lt;句子&gt;,&lt;名词短语&gt;,&lt;名词短语&gt;,&lt;动词&gt;,...}V_N = \\{&lt;句子&gt;,&lt;名词短语&gt;,&lt;名词短语&gt;,&lt;动词&gt;,...\\}VN​={&lt;句子&gt;,&lt;名词短语&gt;,&lt;名词短语&gt;,&lt;动词&gt;,...}\n\nVTV_TVT​：终结符集\n\n**终结符(terminal symbol)**是文法所定义的语言的基本符号，有时也称为token\n例：VT={apple,boy,eat,little}V_T = \\{apple,boy,eat,little\\}VT​={apple,boy,eat,little}\n\nPPP：产生式集合（规则集合）\n\n**产生式(production)**描述了将终结符和非终结符组合成串的方法\n产生式的一般形式：α→β\\alpha → \\betaα→β 读作：α\\alphaα定义为β\\betaβ\n\nSSS：开始符号（识别符号）\n\n**开始符号(start symbol)**表示的是该文法中最大的语法成分，S∈VNS \\in V_NS∈VN​\n其中，\n\nVN,VT和P是非空有穷集V_N,V_T和P是非空有穷集VN​,VT​和P是非空有穷集\nS∈VN,并且S至少在一条规则中作为左部出现S \\in V_N,并且S至少在一条规则中作为左部出现S∈VN​,并且S至少在一条规则中作为左部出现\nVN∩VT=∅V_N \\cap V_T = ∅VN​∩VT​=∅\nV=VN∪VT,V称为文法G的字母表V = V_N \\cup V_T,V称为文法G的字母表V=VN​∪VT​,V称为文法G的字母表\n\n例：\n文法G=(VN,VT,P,S)G = (V_N,V_T,P,S)G=(VN​,VT​,P,S)\nVN={S}V_N = \\{S\\}VN​={S}\nVT={0,1}V_T = \\{0,1\\}VT​={0,1}\nP={S→0S1,S→01}P=\\{S → 0S1,S → 01\\}P={S→0S1,S→01}\nSSS为开始符号\n文法的简写形式：\n只写出产生式 或者 G写成G[S]，S是开始符号\nG:S→0S1G: S → 0S1G:S→0S1\nS→01S → 01S→01\n 文法的类型\n\n0型、1型、2型和3型。\n差别在于对产生式的不同限制。\n\n 0型文法（短语文法）\n\nα→β\\alpha → \\betaα→β, 其中α∈(VN∪VT)∗\\alpha \\in (V_N \\cup V_T)^*α∈(VN​∪VT​)∗，（*表示闭包，用集合中的任意一个元素组合形成的串), 且至少含有一个非终结符，而β∈(VN∪VT)∗\\beta \\in (V_N \\cup V_T)^*β∈(VN​∪VT​)∗。\n\n0型文法也称短语文法。\n0型文法的能力相当于图灵机，任何0型语言都是递归可枚举的，即递归可枚举集必定是一个0型语言。\n一般见到的文法都可看做0型文法。\n例如：A→ab,A→Cb,A→bA → ab, A → Cb, A→bA→ab,A→Cb,A→b\n 1型文法（上下文有关文法）\n\nα→β\\alpha → \\betaα→β, 均满足 ∣α∣≤∣β∣|\\alpha| \\le |\\beta|∣α∣≤∣β∣，除α→ϵ\\alpha → \\epsilonα→ϵ外。\n\n1型文法又称上下文有关文法。\n产生式左部可以有多个字符，但必须有一个非终结符；产生式右部可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符且左部长度必须小于右部（α→ϵ\\alpha → \\epsilonα→ϵ除外）。\n例如：A→B,A→Bab,Bc→AA → B, A →Bab, Bc → AA→B,A→Bab,Bc→A\n 2型文法（上下文无关文法）\n\n产生式形式：A→βA → \\betaA→β\n\n2型文法又称上下文无关文法。\n产生式左部必须是非终结符，然而一个终结符一个非终结符的组合不是非终结符，如Ab就不是一个非终结符，但是两个非终结符的组合就是一个非终结符，如AB。\n产生式右部字符任意，可终结符，也可非终结符，但必须是有限个字符。\n例如：AB→ab,B→AbAB → ab, B → AbAB→ab,B→Ab\n 3型文法（正规文法）\n3型文法又称正规文法，而正规文法又包括左线性文法和右线性文法。\n 左线性文法\n\n产生式形式：A→αBA → \\alpha BA→αB 或 A→αA → \\alphaA→α\n\n左部只能有一个字符，且必须为非终结符；\n右部最多有两个字符，如果有两个字符，必须为终结符+非终结符格式，如果是一个字符，必须为终结符。\n例如：B→aBB → aBB→aB\n 右线性文法\n\n产生式形式： 或 A→αA → \\alphaA→α\n\n左部只能有一个字符，且必须为非终结符；\n右部最多有两个字符，如果有两个字符，必须为非终结符+终结符格式，如果是一个字符，必须为终结符。\n例如：B→BaB → BaB→Ba\n所以左右线性文法的区别就在于右部的非终结符在右部两个字符的左还是右。\n 推导⇒\n给定文法G={VT,VN,P,S}G=\\{V_T,V_N,P,S\\}G={VT​,VN​,P,S}，如果α→β∈P\\alpha →\\beta \\in Pα→β∈P，那么可以将符号串中的α\\alphaα替换为β\\betaβ，即将**γαδ\\gamma \\alpha \\deltaγαδ**重写(rewrite)为 γβδ\\gamma \\beta \\deltaγβδ，记作γαδ\\gamma \\alpha \\deltaγαδ ⇒ γβδ\\gamma \\beta \\deltaγβδ。\n此时，称文法中的符号串γαδ\\gamma \\alpha \\deltaγαδ **直接推导（directly derive）**出 γβδ\\gamma \\beta \\deltaγβδ\n即，用产生式的右部替换产生式的左部\n\n⇒n⇒^n⇒n：经过n步推导\n⇒+⇒^+⇒+：表示经过正数步推导\n⇒∗⇒^*⇒∗：表示经过若干（可以是0）步推导\n\n 归纳\n上文有讲，归纳即推导的逆过程，看下图可直观理解推导与归纳的关系。\n\n 最左（最右）推导\n所谓最左（最右）推导，是指对于一个推导序列中的每一步直接推到 α\\alphaα ⇒ β\\betaβ ，都是对 α\\alphaα 中的最左（最右）非终结符进行替换。\n例如，设有文法G[S]:\nS → N\nN → NH | H\nH → 0 | 1 | 2\n该文法所定义的语言是由数字0, 1, 2组成的所有无符号整数集合，其中符号串01是该文法的一个句子，那么此句子可以通过不同的推到序列得到（注意加粗字符）：\n\nS ⇒ N ⇒ NH ⇒ N1 ⇒ H1 ⇒ 01\nS ⇒ N ⇒ NH ⇒ HH ⇒ 0H ⇒ 01\nS ⇒ N ⇒ NH ⇒ HH ⇒ H1 ⇒ 01\n\n在上面三个推导序列中：\n\n是最右推导，每次都是把最右边的字符推导完成；\n是最左推导，每次都是把最左边的字符推导完成；\n这次左下次右，跟渣男（女）似的推导，既不是最右推导也不是最左推导。\n\n 规范推导和规范归纳\n最右推导也称为规范推导，用规范推导推导出的句型称为规范句型。\n规范推导的逆过程称为最左归纳，也称为规范归纳。\n 句型和句子\n如果  ，则称aaa是GGG的一个 句型(sentential form) ，\n一个句型中既可以包含终结符，又可以包含非终结符，也可能是空串。\n如果S⇒∗w,w∈VT∗S⇒^* w,w \\in V_{T}^{*}S⇒∗w,w∈VT∗​，则称www是GGG的一个句子(sentence),\n句子是不包含非终结符的句型。\n 语言的定义\n\nL(G)={x∣S⇒∗x,其中S为文法的开始符号,x∈VT∗}L(G) = \\{ x|S ⇒^* x,其中S为文法的开始符号, x \\in V_T^* \\}L(G)={x∣S⇒∗x,其中S为文法的开始符号,x∈VT∗​}\n\n由文法G生成的语言记为L(G)，它是文法G的一切句子的集合。\n例如：G:S→0S1,S→01G: S → 0S1, S → 01G:S→0S1,S→01，显然任意句子的左边都是0，右边都是1，且个数相等。\nL(G)={0n1n∣n≥1}L(G)= \\{ 0^n 1^n | n\\ge 1 \\}L(G)={0n1n∣n≥1}\n文法的等价：若L(G1)=L(G2)L(G_1)=L(G_2)L(G1​)=L(G2​)，则文法G1G_1G1​和G2G_2G2​是等价的。\n例如：G1[A]:A→0R,A→01,R→A1G_1[A]: A → 0R, A → 01, R →A1G1​[A]:A→0R,A→01,R→A1等价于G2[S]:S→0S1,S→01G_2[S]: S→0S1, S→01G2​[S]:S→0S1,S→01。\n 根据已知文法求语言∗^*∗\n根据语言定义：语言是文法的一切句子的集合。\n集合的表示形式为：L(G)={α∣S⇒+α,α∈VT∗}L(G)= \\{ \\alpha | S⇒^+ \\alpha ,\\alpha \\in V_T^*  \\}L(G)={α∣S⇒+α,α∈VT∗​}\n假设有文法：G(S):S→aSb∣abG(S): S → aSb | abG(S):S→aSb∣ab.\n可知开始符为G，有两个产生式，分别为S→aSb,S→abS → aSb, S → abS→aSb,S→ab，采用递归的方式，任意组合，进行一步或有限步的推导，使得生成式右部不含有非终结符。\n如果右部存在非终结符（类似于递递递…不归）时，就需要进行归纳。\n所以L(G)={anbn∣n≥1}L(G) = \\{ a^n b^n|n \\ge 1 \\}L(G)={anbn∣n≥1}\n按产生式出现的顺序规定优先级由高到低。\n再来一个例题：\nG[S]：S-&gt;aSPQ|abQ\nQP-&gt;PQ\nbP-&gt;bb\nbQ-&gt;bc\ncQ-&gt;cc\n求其语言为？\nsolution：\n假设递归S三次，可得S → aaabQPQPQ\n由QP → PQ，可得S → aaabPPQQQ\n由bP → bb，可得S → aaabbbQQQ\n由bQ → bc，可得S → aaabbbcQQ\n由cQ → cc，可得S → aaabbbccc\n至此产生式右部无非终结符，递归S三次的句子为aaabbbccc\n将递归推广至n次这句子为aa...aabb...bbcc...cc\n即L(G)={anbncn∣n≥1}L(G)=  \\{ a^n b^n c^n |n \\ge 1 \\}L(G)={anbncn∣n≥1}\n\n递归之所以递归，就是其运算规则不变，所以1次和n次是一样的。\n\n 文法构造与文法简化∗^*∗\n 文法构造（由语言构造文法）\n\n常用方法有4个：对称法、分解法、等价法、电路状态转换法\n记两个常用的。\n\n 对称法\n\n适用于存在对称性的语言\n\n上面求语言的例子就是存在对称性的语言\n对称法构造的核心是找出对称轴、找对称性。\n例如：L(G)={a2nbn∣n≥1,a,b∈VT}L(G) = \\{ a^{2n} b^n | n \\ge 1 ,a,b \\in V_T \\}L(G)={a2nbn∣n≥1,a,b∈VT​}\nn = 1时，L = aab；n = 2时，L = aaaabb\n所以可以推出 S→aaSb∣aabS → aaSb | aabS→aaSb∣aab\n 分解法\n分解法也叫逐步求精法，有两种方法：自上而下、从左至右。\n使用前提是语言中各成分之间没有关联。\n例如：L(G)={aibjck∣i,j,k≥1且a,b,c∈VT}L(G) = \\{ a^ib^jc^k | i,j,k \\ge 1 且a,b,c \\in V_T \\}L(G)={aibjck∣i,j,k≥1且a,b,c∈VT​}\n自上而下：\n将aibjcka^ib^jc^kaibjck各自看成一个整体，由i≥1i \\ge 1i≥1，可知语言中最少存在一个a，因此可得A→aA∣aA → aA|aA→aA∣a。\n同理可得其他两个整体，B→bB∣b,C→cC∣cB→bB|b,C→cC|cB→bB∣b,C→cC∣c.\n综上所述S→ABC,A→aA∣a,B→bB∣b,C→cC∣cS → ABC, A → aA|a, B→bB|b, C→cC|cS→ABC,A→aA∣a,B→bB∣b,C→cC∣c。\n从左至右：\naibjck=a∗ai−1bjcka^ib^jc^k=a^*a^{i-1}b^jc^kaibjck=a∗ai−1bjck，其中i−1≥0i - 1\\ge 0i−1≥0。\n当i−1≥1i-1\\ge 1i−1≥1时，S→aSS → aSS→aS；当i−1=0i - 1 = 0i−1=0时，S→aAS→ aAS→aA.\n其中A对应的语言是bjckb^j c^kbjck，同理推出A→bA∣bBA → bA|bBA→bA∣bB。\n综上所述，S→aS∣aA,A→bA∣bB,B→cB∣cS→aS|aA, A→bA|bB,B→cB|cS→aS∣aA,A→bA∣bB,B→cB∣c。\n我觉得自上而下简单些。\n 文法化简*\n化简步骤：\n\n删除形如P→P的产生式；\n删除永不被使用的产生式，即由文法的开始符号无法推导出其左部；\n删除不能从中导出终结符串的产生式；\n整理产生式；\n\n下面是几个例题：\n例1\n\nS → aABS | bCACd\nA → bAB | cSA | cCC\nB → bAB | cSB\nC → cS | c\n\nB能推导的两个右部都包含自己，即满足第三个步骤不从中导出终结符的产生式，所以删去所有和B有关的产生式，得到：\nS → bCACd\tA → cSA | cCC\tC → cS | c\n此时这个文法与原文法等价，并且不包含无用符号和无用产生式。\n例2\n\nS → aAB | E\nA → dDA | e\nB → bE | f\nC → cAB | dSD | a\nD → eA\nE → fA | g\n\n这种题就从开始符号出发，看看谁不会被推导到，这时发现C推导不出，因此C是无用符号，删去所有和C有关的产生式，得到：\nS → aAB | E\tA → dDA | e\tB → bE |f\tD → eA\tE → fA | g\n此时这个文法与原文法等价，并且不包含无用符号和无用产生式。\n例3（暂不确定是否正确）\n\nS → ac | bA\nA → cBC\nB → SA\nC → bC | d\n\nA → cBC 而 B → SA，显然这将不可得到终结符串，因此需要删去所有和A B有关的产生式，得到：S → ac\tC → bC | d\n而此时C永远不会被使用，因此它是一个无用符号，删去后最终得到：S → ac\n 构造无产生式的上下文无关文法\n 语法树与文法的二义性\n 语法树\n 基本术语\n 文法的二义性\n\n 词法分析\n\n词法分析是编译的第一个阶段，其主要任务是从左至右逐个字符地对源程序进行扫描，产生一个个单词序列，用以语法分析。\n\n 单词的描述工具\n 正规文法\n 正规式\n 有穷自动机\n 状态转换图\n 确定的有穷自动机\n 不确定的有穷自动机\n NFA转换为等价的DFA\n DFA的化简\n 正规式和有穷自动机的等价性\n 正规文法和有穷自动机的等价性\n","categories":["笔记"],"tags":["编译原理"]},{"title":"泰勒公式","url":"/2023/10/27/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/","content":" 泰勒公式\n\n泰勒公式的本质是近似\n\n 常用泰勒公式\n11−x=1+x+x2+x3+x4+...+xn+o(xn),−1&lt;x&lt;1\\frac{1}{1-x} = 1+x+x^2+x^3+x^4+...+x^n +o(x^n),-1 \\lt x \\lt 11−x1​=1+x+x2+x3+x4+...+xn+o(xn),−1&lt;x&lt;1\n11+x=1−x+x2−x3+x4+...+(−1)nxn+o(xn),−1&lt;x&lt;1\\frac{1}{1+x} = 1-x+x^2-x^3+x^4+...+(-1)^nx^n +o(x^n),-1 \\lt x \\lt 11+x1​=1−x+x2−x3+x4+...+(−1)nxn+o(xn),−1&lt;x&lt;1\nln(1+x)=x−x22+x33+...+(−1)n−1xnn+o(xn),−1&lt;x≤1ln(1+x)=x- \\frac{x^2}{2}+ \\frac{x^3}{3}+...+(-1)^{n-1} \\frac{x^n}{n}+o(x^n),-1 \\lt x \\le 1ln(1+x)=x−2x2​+3x3​+...+(−1)n−1nxn​+o(xn),−1&lt;x≤1\n$e^x=1+x+ \\frac{x2}{2!}+\\frac{x3}{3!}+…+\\frac{xn}{n!}+o(xn), -\\infty \\lt x \\lt +\\infty $\n$\\sin x=x-\\frac{x3}{3!}+\\frac{x5}{5!}+…+(-1)n\\frac{x{2n+1}}{(2n+1)!}+o(x^{2n+1}),-\\infty \\lt x \\lt +\\infty $\n$\\cos x = 1-\\frac{x2}{2!}+\\frac{x4}{4!}+…+(-1)^n \\frac{x^{2n}}{(2n)!},-\\infty \\lt x \\lt +\\infty $\ntan⁡x=x+x33+o(x3)\\tan x=x+\\frac{x^3}{3}+o(x^3)tanx=x+3x3​+o(x3)\narctan⁡x=x−x33+o(x3)\\arctan x=x-\\frac{x^3}{3}+o(x^3)arctanx=x−3x3​+o(x3)\narcsin⁡x=x+x33!+o(x3)\\arcsin x=x+\\frac{x^3}{3!}+o(x^3)arcsinx=x+3!x3​+o(x3)\n(1+x)α=1+αx+α(α−1)2!x2+α(α−1)(α−2)3!x3+o(x3)(1+x)^ \\alpha = 1+\\alpha x+\\frac{\\alpha (\\alpha - 1)}{2!}x^2 + \\frac{\\alpha (\\alpha - 1)(\\alpha - 2)}{3!}x^3+o(x^3)(1+x)α=1+αx+2!α(α−1)​x2+3!α(α−1)(α−2)​x3+o(x3)\n 泰勒公式Taylor Formula\n如果f(x0)f(x_0)f(x0​)在nnn阶可导，则有\nf(x0)=f(x0)+f′(x0)1!(x−x0)+f′′(x0)2!(x−x0)2+...+fn(x0)n!(x−x0)n+o[(x−x0)n]f(x_0)=f(x_0)+\\frac{f^{'}(x_0)}{1!}(x-x_0)+\\frac{f^{''}(x_0)}{2!}(x-x_0)^2+...+\\frac{f^{n}(x_0)}{n!}(x-x_0)^n+o[(x-x_0)^n]f(x0​)=f(x0​)+1!f′(x0​)​(x−x0​)+2!f′′(x0​)​(x−x0​)2+...+n!fn(x0​)​(x−x0​)n+o[(x−x0​)n]\n 麦克劳林级数Maclaurin’s series\n当x0x_0x0​为0时：\nf(x0)=f(x0)+f′(x0)1!x+f′′(x0)2!x2+...+fn(x0)n!xn+o(xn)f(x_0)=f(x_0)+\\frac{f^{'}(x_0)}{1!}x+\\frac{f^{''}(x_0)}{2!}x^2+...+\\frac{f^{n}(x_0)}{n!}x^n+o(x^n)f(x0​)=f(x0​)+1!f′(x0​)​x+2!f′′(x0​)​x2+...+n!fn(x0​)​xn+o(xn)\n 使用\n什么时候用泰勒公式？\n展开到第几项？\n","categories":["笔记"],"tags":["数学"]},{"title":"最长公共子序列(LCS)","url":"/2023/10/27/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","content":" 最长公共子序列+模板\n 定义\n最长公共子序列，英文缩写为LCS（Longest Common Subsequence）。一个序列S，如果分别是两个或多个已知的序列的子序列，并且是所有子序列中最长的，则称序列S为最长公共子序列。\n如序列1 2 3 4 5 6 7 8和序列5 6 7 8 1 2 3 4，他们的最长公共子序列为1 2 3 4和5 6 7 8，其长度为4，由此可知，最长公共子序列也唯一，但长度唯一。\n最长公共子序列，可以识别两段文字之间的“相似度”，即查重。\n 解法\n 动态规划O(nm)O(nm)O(nm)\n最长公共子序列问题具有最优子结构和重复子问题，因此可以考虑动态规划。\n设C[i,j]=LCS(a[1...i],b[1...j])C[i,j] = LCS(a[1...i],b[1...j])C[i,j]=LCS(a[1...i],b[1...j])，C[i,j]C[i,j]C[i,j]表示序列a和b的长度分为i和j时的最长公共子序列的长度，则C[n,m]C[n,m]C[n,m]就是序列a和b的最长公共子序列。\n**状态表示：**dp[i][j] 为序列a到i位置和序列b到j位置时的最长公共子序列。\n状态转移： dp[i][j]={dp[i−1][j−1]+1,a[i]=b[j]max(dp[i−1][j],dp[i][j−1]),a[i]≠b[j]dp[i][j] = \\begin{cases} dp[i-1][j-1]+1 &amp;, a[i] = b[j] \\\\ max(dp[i-1][j],dp[i][j-1]) &amp; ,a[i] ≠ b[j] \\end{cases}dp[i][j]={dp[i−1][j−1]+1max(dp[i−1][j],dp[i][j−1])​,a[i]=b[j],a[i]=b[j]​\nfor (int i = 1;i &lt;= n;i ++) \tfor (int j = 1;j &lt;= m;j ++) \t\tif (a[i] == b[j])\tdp[i][j] = dp[i - 1][j - 1] + 1;\t\telse dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]);\n","categories":["动态规划"],"tags":["动态规划","dp","LCS"]},{"title":"最长上升子序列(LIS)","url":"/2023/10/27/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","content":" 最长上升子序列+模板\n 定义\n最长上升子序列（Longest Increasing Subsequence），简称LIS。还有一种最长非降子序列，其区别是LIS没有相等的数，例如1 2 3是一个最长上升子序列，而1 2 2 3是一个最长非降子序列。\n对于一个序列a1,a2,...,ana_1,a_2,...,a_na1​,a2​,...,an​,有子序列a1,a2,...,aka_1,a_2,...,a_ka1​,a2​,...,ak​，其中 1≤a1≤a2≤...≤ak≤n1 \\le a_1 \\le a_2 \\le ...\\le a_k \\le n1≤a1​≤a2​≤...≤ak​≤n.我们称这个样一个子序列是一个上升子序列，而求出这样最长的上升子序列，便是本篇文章要学习的内容。\n对于序列1 5 3 7 2 4 6，其中的上升子序列有1 5 7,1 3 7,1 3 4 6,1 2 4 6……而这些子序列中最长的有1 3 4 6和1 2 4 6，长度为4，所以该序列的最长上升子序列为4。同时可以发现最长上升子序列不唯一，一个序列可以有多个最长上升子序列，但是长度唯一。\n 解法\n 动态规划 O(n2)O(n^2)O(n2)\n将复杂问题拆分成多个简单问题。\n求长度为n的序列的LIS，实际上是在长度为n-1的序列上推过来的，因此可用DP求解。\n**状态表示：**dp[i] 为以a[i]结尾的最长上升子序列的长度。\n**状态转移：**dp[i] = max(dp[i],dp[j] + 1)，其中1 &lt;= j &lt; i,a[j] &lt; a[i]。\n也就是说，对于每个a[i]，每次都向前找比它小的数，然后找到以a[i]结尾的最长的子序列。\n由于每次都要循环两次，因此时间复杂度为O(n2)O(n^2)O(n2)，这是一个很大的时间复杂度，在数据范围庞大的时候，此方法不适合。\n CODE\nfor (int i = 1;i &lt;= n;i ++) {\tdp[i] = 1;    for (int j = 1;j &lt; i;j ++)        if (a[j] &lt; a[i])            dp[i] = max(dp[i],dp[j] + 1);   \tans = max(ans,dp[i]);}\n\n 贪心+二分 O(nlogn)O(nlogn)O(nlogn)\n对于上升子序列，其结尾元素越小越有利于增长。定义一个数组f存放这个最长上升子序列，最后数组f的长度就是答案。\n对于每个a[i]，如果a[i] &gt; f[len]，则f[++ len] = a[i]；如果a[i] &lt;= f[len]，则用a[i]更新f数组，在f数组中找到第一个大于等于a[i]的元素f[j]，用a[i]更新f[j]。由于f数组是单调递增的，所以可以使用二分来查找这个应该更新的位置，二分查找的时间复杂度为O(logn)O(logn)O(logn)，因此总的时间复杂度为O(nlogn)O(nlogn)O(nlogn)。\n CODE\nf[++len] = a[1];for (int i = 2;i &lt;= n;i ++)\tif (a[i] &gt; f[len])\tf[++ len] = a[i];\telse \tf[find(a[i])] = a[i];\n其中find函数为\nint find(int x) {\tint l = 1,r = len;\twhile(l &lt; r) {\t\tint mid = l + r &gt;&gt; 1;\t\tif (f[mid] &lt; x) l = mid + 1;\t\telse r = mid;\t}\treturn l;}\n lower_bound()函数\nC++中可用lower_bound()函数代替二分查找第一个大于等于查找元素的位置。\nf[++len] = a[1];for (int i = 2;i &lt;= n;i ++)\tif (a[i] &gt; f[len])\tf[++ len] = a[i];\telse {\t\tint idx = lower_bound(&amp;f[1],&amp;f[len],a[i]) - &amp;f[0];\t\tf[idx] = a[i];\t}\n","categories":["动态规划"],"tags":["LIS","动态规划","dp","二分"]},{"title":"大一三问","url":"/2023/10/27/%E5%A4%A7%E4%B8%80%E4%B8%89%E9%97%AE/","content":" 大一三问\n 平衡\n如何寻求竞赛与学业之间的平衡？\n 节奏\n如何找到一种有规律的、有活力的、健康的、适合自己的生活、学习节奏？\n 取舍\n应该适当舍去什么，用“舍”到的时间来“取”得什么？\n\n\n2021年冬，于公交楼写。\n","categories":["日记"]},{"title":"XML学习笔记","url":"/2023/10/27/XML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":" XML\n\nXML 是独立于软件和硬件的信息传输工具。\n\n 什么是XML？\n\nXML 指可扩展标记语言（EXtensible Markup Language）\nXML 是一种标记语言，很类似 HTML\nXML 的设计宗旨是传输数据，而非显示数据\nXML 标签没有被预定义。您需要自行定义标签。\nXML 被设计为具有自我描述性。\nXML 是 W3C 的推荐标准\n\n\n XML与HTML的差别\nXML 不是 HTML 的替代。\nXML 和 HTML 为不同的目的而设计：\nXML 被设计为传输和存储数据，其焦点是数据的内容。\nHTML 被设计用来显示数据，其焦点是数据的外观。\nHTML 旨在显示信息，而 XML 旨在传输信息。\n\n XML的用途\nXML 应用于 web 开发的许多方面，常用于简化数据的存储和共享。\nXML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。\n通过 XML，可以在不兼容的系统之间轻松地交换数据。\n\n XML的声明\n一个XML实例：\n&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;&lt;note&gt;\t&lt;body&gt;Hello, XML&lt;/body&gt;&lt;/note&gt;\n第一行是XML声明，它定义XML版本为1.0，所使用的编码为ISO-8859-1\n以下是XML的处理指令，以&lt;?开头，以?&gt;结尾\n&lt;?  ?&gt;\n\n XML 树结构\n\nXML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。\n\nXML 文档必须包含根元素。该元素是所有其他元素的父元素。\nXML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。\n所有元素均可拥有子元素：\n&lt;root&gt;  &lt;child&gt;    &lt;subchild&gt;.....&lt;/subchild&gt;  &lt;/child&gt;&lt;/root&gt;\n\n XML语法规则\n\nXML的语法规则很简单，容易学习\n\n 所有XML元素都要有关闭标签\n在HTML中，下面代码是没有关闭标签的元素：\n&lt;p&gt; Hello, XML\n在XML中，如果省略了关闭标签是违反语法规则的。\n&lt;p&gt; Hello, XML &lt;/p&gt;\n**注意：**XML的声明没有关闭标签，是因为声明不属于XML的元素，不需要关闭标签\n XML标签对大小写敏感\n XML必须正确嵌套\n在HTML中，没有正确嵌套的元素有时是可以使用的：\n&lt;b&gt;&lt;i&gt; Hello, XML &lt;/b&gt;&lt;/b&gt;i&gt;\n在XML中，所有元素都必须正确嵌套：\n&lt;b&gt;&lt;i&gt; Hello, XML &lt;/i&gt;&lt;/b&gt;\n XML文档必须有根元素\n上文提到过XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。\n因此XML文档必须有一个元素是其他所有元素的父元素。\n XML的属性值加引号\n例如给下面的date属性赋值，其属性值必须加引号：\n&lt;note date=\"09/15/2023\"&gt;&lt;name&gt;XML&lt;/name&gt;&lt;/note&gt; \n单引号和双引号都可以。\n 实体引用\n在XML中，一些字符拥有特殊的意义，如&lt;、&gt;。\n如果把字符&lt;放在XML元素中，会发生错误，这是因为解析器遇到&lt;会把它当作新元素的开始。\n因此需要使用实体引用来代替这些特殊字符。\n在XML中，有5个预定义的实体引用：\n\n\n\n实体引用\n字符\n含义\n英语单词\n\n\n\n\n&amp;lt;\n&lt;\n小于\nless than\n\n\n&amp;gt;\n&gt;\n大于\ngreater than\n\n\n&amp;amp;\n&amp;\n和号\nampersand\n\n\n&amp;apos;\n’\n单引号\napostrophe  [计]撇号；\n\n\n&amp;quot;\n\"\n引号\nquotes\n\n\n\n这和在Markdown中的用法一样。\n**注意：**在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。\n XML中的注释\n与HTML类似\n&lt;!-- This is a comment --&gt;\n 在XML中，空格会被保留\nHTML 会把多个连续的空格字符裁减（合并）为一个，在 XML 中，文档中的空格不会被删节。\n\n XML元素\n 什么是XML元素？\nXML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。\n元素可以包含其他元素或文本，元素可以拥有属性（属性值用引号。\n XML元素命名规则\n\n名称可以含字母、数字以及其他的字符\n名称不能以数字或者标点符号开始\n名称不能以字符 “xml”（或者 XML、Xml）开始\n名称不能包含空格\n\n可使用任何名称，因为XML没有保留的关键字。\n最佳命名习惯是使名称具有描述性。名称应当比较简短，避免使用-、.、:这些字符。\n XML元素是可扩展的\nXML 的优势之一，就是可以经常在不中断应用程序的情况进行扩展。\n\n XML属性\n元素的属性必须有属性值，且属性值必须用引号括起来。\n请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。\n有时候会向元素分配 ID 引用。这些 ID 索引可用于标识 XML 元素，它起作用的方式与 HTML 中 ID 属性是一样的。\n例如：\n&lt;root&gt;\t&lt;note id=\"0\"&gt;\t\t&lt;body&gt;Hello&lt;/body&gt;\t&lt;/note&gt;\t&lt;note id=\"1\"&gt;\t\t&lt;body&gt;World&lt;/body&gt;\t&lt;/note&gt;&lt;/root&gt;\n\n XML验证\n\n拥有正确语法的 XML 被称为“形式良好”的 XML。\n通过 DTD 验证的 XML 是“合法”的 XML。\n\n 形式良好的XML文档\nXML文档拥有正确的语法\n\nXML 文档必须有根元素\nXML 文档必须有关闭标签\nXML 标签对大小写敏感\nXML 元素必须被正确的嵌套\nXML 属性必须加引号\n\n 验证XML文档\n合法的XML文档是“形式良好”的XML文档，同样遵守了文档类型定义（DTD）的语法规则。\n\n 文档类型定义（DTD）\n\n文档类型定义（DTD）可定义合法的XML文档构建模块。\n它使用一系列合法的元素来定义文档的结构。\nDTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。\n\n 内部DTD的引用\n\nXML和DTD在同一个XML文本中存在\n\n它应当通过下面的语法包装在一个 DOCTYPE 声明中：\n&lt;!DOCTYPE 根元素 [元素声明] &gt;\n注意：关键字DOCTYPE必须大写。\n 外部DTD的引用\n\n将DTD作为一个单独的文件独立保存，该DTD是一个文本文件，扩展名为.dtd。\n\n引入外部DTD文档，需要在XML文本中的DOCTYPE指令中使用关键字SYSTEM或者PUBLIC进行引用，以达到对XML文本数据的规范。\n&lt;!DOCTYPE 根元素 SYSTEM \"文件名\" &gt;\n外部DTD作为一个外部文件可以被多个XML文档引用。\n对于外部DTD，根据其性质分为两种：\n\n公有文件，指国际上标准组织制定或者行业内部得到广泛支持认可的DTD文件，使用关键字PUBLIC。\n私有文件，指未公开的、属于个人或某些组织的DTD文件，使用关键字SYSTEM。\n\n内部DTD和外部DTD可以混合使用。\n 为什么使用DTD？\n通过 DTD，每一个 XML 文件均可携带一个有关其自身格式的描述。\n通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。\n可以使用 DTD 来验证自身的数据。\n DTD建构模块\n所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：\n\n元素\n属性\n实体\nPCDATA\nCDATA\n\n 元素\n元素是 XML 以及 HTML 文档的主要构建模块。\nXML元素的例子是\"note\"和\"message\"。\n 属性\n属性提供有关元素的额外信息。\n属性总是被置于某元素的开始标签中。属性总是以名称/值的形式成对出现的。\n 实体\n实体是用来定义普通文本的变量。实体引用是对实体的引用。\n PCDATA\nPCDATA 的意思是被解析的字符数据（parsed character data）。\n可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。\n CDATA\nCDATA 的意思是字符数据（character data）。\n**CDATA 是不会被解析器解析的文本。**在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。\n DTD元素\n\nELEMENT\n\n 声明一个元素\n在 DTD 中，XML 元素通过元素声明来进行声明。\n&lt;!ELEMENT 元素名称 类别&gt;\n或\n&lt;!ELEMENT 元素名称 (元素内容)&gt;\n 空元素\n&lt;!ELEMENT 元素名称 EMPTY&gt;\n 只有 PCDATA 的元素\n只有 PCDATA 的元素通过圆括号中的 #PCDATA 进行声明：\n&lt;!ELEMENT 元素名称 (#PCDATA)&gt;\n 带有任何内容的元素\n通过类别关键词 ANY 声明的元素，可包含任何可解析数据的组合：\n&lt;!ELEMENT 元素名称 ANY&gt;\n 带有子元素（序列）的元素\n带有一个或多个子元素的元素通过圆括号中的子元素名进行声明：\n&lt;!ELEMENT 元素名称 (子元素名称 1)&gt;\n或\n&lt;!ELEMENT 元素名称 (子元素名称 1,子元素名称 2,.....)&gt;\n 声明只出现一次的元素\n&lt;!ELEMENT 元素名称 (子元素名称)&gt;\n 声明最少出现一次的元素\n&lt;!ELEMENT 元素名称 (子元素名称+)&gt;\n 声明出现零次或多次的元素\n&lt;!ELEMENT 元素名称 (子元素名称*)&gt;\n DTD属性\n\nATTLIST\n\n 声明属性\n&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;\n 规定一个默认的属性值\nDTD：\n&lt;!ELEMENT square EMPTY&gt;&lt;!ATTLIST square width CDATA \"0\"&gt;\n“square” 被定义为带有 CDATA 类型的 “width” 属性的空元素。如果宽度没有被设定，其默认值为0 。\n DTD实体\n\n实体是用于定义引用普通文本或特殊字符的快捷方式的变量。\n实体引用是对实体的引用。\n实体可在内部或外部进行声明。\n\n 一个内部实体声明\n&lt;!ENTITY 实体名称 \"实体的值\"&gt;\n 一个外部实体声明\n&lt;!ENTITY 实体名称 SYSTEM \"URI/URL\"&gt;\n\n XML关联CSS的方式\n通过使用CSS(Cascading Style Sheets 层叠样式表)，可以将显示信息添加到XML文档中。\n通过以下代码将XML文件链接到CSS文件：\n&lt;?xml-stylesheet type=\"text/css\" href=\"***.css\"?&gt;\n通过 工具-在浏览器预览 或 F6 显示\n CSS语法\n由三部分构成：选择器（selector）、属性（property）、属性值（value）\nselector {\tproperty1: value;\tproperty2: value;\tproperty3: value;}\n注意：虽然在CSS中不区分大小写，但是在XML中区分大小写，因此需要注意与XML中一致。\n","categories":["笔记"],"tags":["XML"]},{"title":"Python基础笔记","url":"/2023/10/27/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":" Python基础学习笔记\n\nPython只是学习其他技术的附带学习，一种工具。\n就好像我要学会种地，必须先学会用锄头。\n\n基于Python3.x版本。\n 简介\n\nPython是一种解释型语言\nPython是交互式语言\nPython是面向对象语言。\nPython是一种代表简单主义思想的语言。\n\n\n 环境变量搭建\n\n\n\n变量名\n描述\n\n\n\n\nPYTHONPATH\nPYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。\n\n\nPYTHONSTARTUP\nPython启动后，先寻找PYTHONSTARTUP环境变量，然后执行此变量指定的文件中的代码。\n\n\nPYTHONCASEOK\n加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.\n\n\nPYTHONHOME\n另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。\n\n\n\n一般安装Python的时候可以勾选自动添加环境变量\n\n 基础语法\n默认情况下，Python 3 的源码文件为UTF-8编码，所有字符串都是unicode字符串。\n可通过下面代码指定不同编码：\n# -*- coding: cp-1252 -*-\nPython每条语句的结束符;可写可不写\n 标识符\n\n首字符必须为字母或_\n标识符只可由字母、数字和下划线组成\n大小写敏感\n中文和非ASCII标识符也可以\n\n 注释\n单行注释：#\n多行注释：多个#、'''和\"\"\"\n'''多行注释'''\n 缩进\nPython最具特色的地方，使用缩进划分语句块，相同缩进数的语句在一起组成一个语句块，不使用大括号{}，\n（我很喜欢\n 多行语句\n如果语句很长，可以使用反斜杠\\来实现多行语句\na = b + \\\tc + \\\td\n在[]、{}、()中的多行语句，不需要使用反斜杠，直接换行就好，但注意缩进美观一些\n 选择结构语句\n if语句\nif a:\tprint(1)elif b:\tprint(2)else:\tprint(3)\nPython 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else。\n if嵌套\nif 表达式1:\t...\tif 表达式2:\t\t...\telif 表达式3:\t\t...\telse\t\t...elif 表达式4:    ...else:    ...\n注意缩进就好了，没啥东西。\nPython 3.10 增加了match...case和C/C++的switch…case类似。\n 循环结构语句\n while循环\nwhile condition:\t#判断条件\tstatements\t\t#执行语句\n执行语句在同一个缩进内就行了。\n如果执行语句只有一条，可以都写在一行：\nwhile condiation:\tstatement\n while循环使用else语句\n如果while后面的条件为false，则会执行else的语句\nwhile condition:\tstatementselse\tadditional_statements\n for语句\nfor &lt;variable&gt; in &lt;sequence&gt;:\t&lt;statements&gt;else:\t&lt;statements&gt;\n挺只能的，类似C++的auto。\n如果要循环数值范围内，用**range()**函数，如：\nfor i in range(n)\t\t#从0遍历到n-1，实际上 i = 0;i &lt; n;i ++for i in range(m,n)\t\t#i = m;i &lt; n;i ++for i in range(m,n,k)\t#i = m;i &lt; n;i += k\n要遍历一个序列，用**len()**获得序列的长度，如\nfor i in range(len(a)):\tprint(i,a[i])\n如果写了else，那么在for循环结束以后执行else语句中的代码。\n如果使用break跳出循环体，对应的else不执行。\n 注释\n 单行注释\n# 注释内容\n 多行注释\n三个单引号\n'''注释内容注释内容'''\n或者\n三个双引号\n\"\"\"注释内容注释内容\"\"\"\n 输出\n 输出函数print()\n# 输出多个参数之间用逗号隔开，依次打印，逗号输出一个空格print(\"Hello\",\"Python\")\n 格式化输出\n# 格式化输出在输出变量时，可以使用%或.format()方法name = \"LZC\"age = 18prop = 0.01print(\"%s今年%d岁了，他有%f元\" % (name,age,prop))\nprint(\"{name}今年{age}岁了，他有{prop}元\".format(name = \"LZC\",age = 18,prop = 0.01))\n 输出不换行的方法\n在Python3.x中，可以使用如下方法不换行：\nprint(\"hello\",end=\"\")print(\"world\")\nend=\"\"可使输出不换行，end的值是这一行结束的内容，可以是空格、换行符或其他什么字符。\n 关于i++和i–\n在Python是没有++和--运算符的！\n 数组\n 列表List\n 定义方式\nlist1 = [1,2,3,4,5]\n 访问\nprint(\"list1:\",list1[0])print(\"list1:\",list1[1:5])\n 更新\n列表是可动态增加元素的\nlist1.append(6)\n 删除\ndel list1[0]#之后编程 2 3 4 5 6，其中2的下标为0\n 函数\n 函数的定义\n函数代码块以def关键字开头，后面是函数名和圆括号，括号内为形参\ndef sayHello():\tprint(\"Hello\")\treturn\n","categories":["笔记"],"tags":["Python"]},{"title":"Oracle学习笔记","url":"/2023/10/27/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":" 浅学Oracle\n\n 数据库工具\n SQL *Plus 是什么？\nSQL *Plus 是Oracle的一个命令行工具，是在Oracle的instant client基础上运行。\n SQL Developer 是什么？\n是Oracle的集成开发环境，例如Java的eclipse，一种数据操作工具。\n DBCA是什么？\nDBCA（Database Configuration Assistant）是Oracle 11g提供的一个具有图形化用户界面的工具，用来帮助数据库管理员快速、直观地创建数据库。\n OEM是什么？\nOracle企业管理器（Oracle Enterprise Manager）简称OEM，是一个基于Java的框架系统，该系统集成了多个组件，为用户提供了一个功能强大的图形用户界面。OEM提供可以用于管理单个Oracle数据库的工具，由于采用了基于Web的界面，它对数据库的访问也是通过HTTP/HTTPS协议，即使用B/S模式访问Oracle数据库管理系统。\n\n 内部结构\n 表空间 tablespace\n表空间是数据库的逻辑划分，一个表空间只属于一个数据库。\n每个表空间由一个或多个数据文件组成，表空间中其他逻辑结构的数据存储在这些数据文件中。\n**EXAMPLE表空间：**EXAMPLE表空间是示例表空间，用于存放示例数据库的方案对象信息及其培训资料。\n**SYSTEM表空间：**SYSTEM表空间是系统表空间，用于存放Oracle系统内部表和数据字典的数据，如表名、列名和用户名等。\n**SYSAUX表空间：**SYSAUX表空间是辅助系统表空间，主要存放Oracle系统内部的常用样例用户的对象，如存放CMR用户的表和索引等，从而减少系统表空间的负荷。SYSAUX表空间一般不存储用户的数据，由Oracle系统内部自动维护。\n**TEMP表空间：**TEMP表空间是临时表空间，存放临时表和临时数据，用于排序和汇总等。\n**UNDOTBS1表空间：**UNDOTBSI表空间是重做表空间，存放数据库中有关重做的相关信息和数据。当用户对数据库表进行修改（包括INSERT、UPDATE和DELETE操作）时，Oracle系统自动使用重做表空间来临时存放修改前的数据。\n**USERS表空间：**USERS表空间是用户表空间，存放永久性用户对象的数据和私有信息，因此也被称为数据表空间。每个数据库都应该有一个用户表空间，以便在创建用户时将其分配给用户。\n 表 table\n表是数据库中存放用户数据的对象。\n 约束条件 constraint\n可以为一个表列创建约束条件。此时，表中的每一行都必须满足约束条件定义所规定的条件。\n**主键（PRIMARY KEY）：**主键是表中的一列或多个列。为表定义主键有如下几个作用：主键包含的列不能输入重复的值，以此来保证一个表的所有行的唯一性；主键也不允许定义此约束的列为NULL值；主键在定义此约束的列中创建了唯一性的索引，利用这个索引可更快地检索表中的行。\n**默认（DEFAULT）：**在表中插入一行数据但没有为列指定值时生成一个在定义表时预先指定的值。\n**检查（CHECK）：**检查约束条件确保指定列中的值符合一定的条件。CHECK列约束条件不能引用一个独立表。非空值约束条件被数据库看成一个CHECK约束条件。\n**唯一性（UNIQUE）：**唯一性约束条件用于保证应具有唯一性而又不是主键的一部分的那些列的唯一性。\n**外键（FOREIGN KEY）：**外键约束条件规定表间的关系性质。一个外键使一个表的一列或多列与已定义为主键的表中的一批相同的列相关联。当在已定义主键约束的表中更新列值时，其他表中定义有外键约束的列会被自动更新。\n 分区 partition\n在非常大的数据库中，可以通过把一个大表的数据分成多个小表来简化数据库的管理，这些小表称为分区。除了对表分区外，还可以对索引进行分区。分区不仅简化了数据库的管理还改善了其应用性能。在Oracle中，能够细分分区，创建子分区。例如，可以根据一组值分割一个表，然后再根据另一种分割方法分割分区。\n 索引 index\n在关系数据库表中，一个行数据的物理位置无关紧要。为了能够找到数据，表中的每一行都用一个RowID来标识。RowID告诉数据库这一行的准确位置，包括所在的文件、该文件中的块和该块中行地址。索引是帮助用户在表中快速地找到记录的数据库结构。它既可以提高数据库性能，又能够保证列值的唯一性。当CREATE TABLE命令中规定有UNIQUE或PRIMARY KEY约束条件子句时，Oracle就会自动创建一个索引。也可以通过CREATE INDEX命令来手工创建自己的索引。\n 用户 user\n用户账号虽然不是数据库中的一个物理结构，但它与数据库中的对象有着重要的关系，这是因为用户拥有数据库的对象。例如，用户SYS拥有数据字典表，这些表中存储了数据库中其他对象的所有信息；用户SYSTEM拥有访问数据字典表的视图，这些视图供数据库其他用户使用。为数据库创建对象（例如表）必须在用户账户下进行。可以对每一个用户账户进行自定义，以便将一个特定的表空间作为它的默认表空间。\n 方案 schema\n用户账户拥有的对象集称为用户的方案（SCHEMA）。可以创建不能注册到数据库的用户账户。这样的用户账户提供一种方案，这种方案可以用来保存一组其他用户方案分开的数据库对象。\n 同义词\n为了给不同的用户使用数据库对象时提供一个简单的、唯一标识数据库对象的名称，可以为数据库对象创建同义词。同义词有公用同义词和私有同义词两种。\n 权限及角色 role\n为了访问其他账户所有的对象，必须首先被授予访问这个对象的权限。权限可以授予给某个用户或PUBLIC，PUBLIC把权限授予数据库中的全体用户。可以创建角色即权限组来简化权限的管理。可以把一些权限授予一个角色，而这个角色又可以被授予多个用户。在应用程序中，角色可以被动态地启用或禁用。\n 段 segment、盘区 extent 和数据块 data block\n依照不同的数据处理性质，可能需要在数据表空间内划分出不同区域，以存放不同数据，将这些区域称为“段”（SEGMENT）。\n例如，存放数据的区域称为“数据区段”、存放索引的区域称为“索引区段”。\n由于段是一个物理实体，所以必须把它分配到数据库中的一个表空间中（放在表空间的一个数据文件中）。而段其实就是由许多盘区组合而成的。当段中的空间用完时，该段就获取另外的盘区。\n数据块是最小的储存单元，Oracle数据库是操作系统块的倍数。\n\n 外部结构\n 数据文件 datafile\n每一个Oracle数据库都有一个或多个数据文件，而一个数据文件只能属于一个表空间。\n数据文件创建后可改变大小，创建新的表空间需要创建新的数据文件。数据文件一旦加入到表空间，就不能从这个表空间中移走，也不能和其他表空间发生联系。\n 重做日志文件 redo log files\nOracle保存所有数据库事务的日志。\n这些事务被记录在联机重做日志文件（Online Redo Log File）中。当数据库中的数据遭到破坏时，可以用这些日志来恢复数据库。\n一个数据库至少需要两个重做日志文件。Oracle以循环方式向重做日志文件写入。第一个日志被填满后，就向第二个日志文件写入，然后依此类推。当所有日志文件都被写满时，就又回到第一个日志文件，用新事务的数据对其进行重写。\n 控制文件 control files\n每个Oracle数据库都有一个控制文件，用以记录与描述数据库的外部结构。\n控制文件内包含：\n\nOracle数据库名称与建立时间；\n数据文件与重做日志文件名称及其所在位置；\n日志记录序列码（Log Sequence Number）。\n\n每当数据库被激活时，Oracle会在实例激活后立刻读取控制文件内容，待所有数据库外部结构文件所在信息都收集完毕，数据库才会启动。\n\n 数据库实例\n数据库实例（Instance）也称为服务器（Server），是指用来访问数据库文件集的存储结构系统全局区（System Global Area，SGA）及后台进程的集合。\n一个数据库可以被多个实例访问，这是Oracle的并行服务器选项。\n 系统全局区\n当激活Oracle数据库时，系统会先在内存内规划一个固定区域，用来存储每位使用者所需存取的数据以及Oracle运作时必备的系统信息。\n这个区域就称为系统全局区（SGA）。\nSGA包含：\n\n数据块缓存区（Data Block Buffer Cache）\n字典缓存区（Dictionary Cache）\n重做日志缓冲区（Redo Log Buffer）\nSQL共享池（Shared SQL Pool）\n\n 数据块缓存区（Data Block Buffer Cache）\n数据块缓存区为SGA的主要成员，用来存放读取数据文件的数据块副本，或是使用者曾经处理过的数据。其用途在于有效减少存取数据时造成的磁盘读/写动作，进而提升数据存取的效率。数据块缓存区的大小由初始化参数DB_BLOCK_BUFFERS决定。数据块缓存区的大小是固定的，它不可能一次装载所有的数据库的内容。通常，数据块缓存区大小只有数据库大小的1%～2%，Oracle使用最近最少使用算法（LRU）来管理可用空间。当存储区需要自由空间时，最近最少使用的块将被移出，释放的存储区空间被新调入的数据块占用。这种算法能够让最频繁使用的数据保留在存储区中。\n 字典缓存区（Dictionary Cache）\n数据库对象的信息存储在数据字典中，这些信息包括用户账户、数据文件名、盘区位置、表说明和权限等。当数据库需要这些信息（如要验证用户账户）时，就要读取数据字典，从中获得需要的信息数据，并且将这些数据存储在SGA的字典缓存区中。\n字典缓存区也是通过LRU算法来管理的。字典缓存区的大小由数据库内部管理。字典缓存区是SQL共享池的一部分，SQL共享池的大小由SHARED_POOL_SIZE参数设置。\n 重做日志缓冲区（Redo Log Buffer）\n在被写入联机重做日志文件之前，事务首先被记录在称为重做日志缓冲区的SGA中。数据库可以周期性地分批向联机重做日志文件中写入修改的内容，从而优化这个操作。\n SQL共享池（Shared SQL Pool）\nSQL共享池存储数据字典缓存区及库缓存区（Library Cache），即对数据库进行操作的语句信息。当使用者将SQL指令送至Oracle数据库后，系统将会先解析语法是否正确。解析时所需要的系统信息，以及解析后的结果将放置在共享区内。如果不同的使用者执行了相同的SQL指令，就可以共享已解析的结果，加速SQL指令的执行速度。SQL共享池的大小由参数SHARED_POOL_SIZE决定。\n 后台进程\n数据库的物理结构和存储结构之间的关系是由后台进程来维持的。数据库拥有多个后台进程，其数量取决于数据库的配置。这些进程由数据库管理，它们只需要进行很少的管理。每个进程在数据库中执行不同的任务。图2.14显示了后台进程在数据库外部结构、SGA中的作用和地位。\n\n 创建数据库\n 表操作\n","categories":["笔记"],"tags":["Oracle"]},{"title":"Java基础学习笔记","url":"/2023/10/27/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":" Java简介\nJava由Sun公司发布于1995年5月，是Java面向对象程序设计语言和Java平台的总称。现在的Java是Oracle公司的产品。\nJava分为三个体系：\n\nJavaSE（Java2 Platform Standard Edition，java平台标准版，简称J2SE）\nJavaEE（Java 2 Platform,Enterprise Edition，java平台企业版，简称J2EE）\nJavaME（Java 2 Platform Micro Edition，java平台微型版，简称J2ME）\n\n2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 “2”：J2EE 更名为 Java EE，J2SE 更名为Java SE，J2ME 更名为 Java ME。\n\n 主要特性\n 简单性\n\n注意：Java底层是C++实现，而非C语言\n\nC中有指针，Java没有指针；C支持多继承，Java使用接口代替多继承。\n 面向对象\n\nEverything is Object.\n\nJava是纯面向对象（封装、继承、多态、抽象），采用类机制。\n 可移植性（跨平台）\n\nCompile Once, Run Anywhere\n\n通过对.java源文件编译得到.class字节码文件，通过java.exe运行在各个平台上的JVM。\n 分布式\nJava 语言支持 Internet 应用的开发，在基本的 Java 应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括 URL、URLConnection、Socket、ServerSocket 等。Java 的 RMI（远程方法激活）机制也是开发分布式应用的重要手段。\n 多线程\n多线程：允许一个应用程序同时存在两个或两个以上的线程，用于支撑事务并发和多任务处理。\n在 Java 语言中，线程是一种特殊的对象，它必须由 Thread 类或其子（孙）类来创建。\nJava 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。\n 健壮性\n自动垃圾回收机制（GC机制）、强类型机制、异常处理等。\n 安全性\nJava程序在JVM（Java虚拟机）中运行。\nJava没有指针等语法，避免了非法操作内存。\nJava 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。\n 高性能\n\nJava属于解释型语言\n\n先编译后解释。\n Java开发环境\n\n搭建Java开发环境前首先需要下载JDK\n\n JDK是什么?\n\nJDK是整个Java开发的核心\n\nJDK（Java Development Kit，Java开发工具包）是由Sun公司开发的，它包括JRE，一堆Java工具（javac.exe、java.exe）和Java基础的类库。\n官网下载地址为Java Downloads | Oracle 中国，目前最新的JDK版本为JDK 19，《Java 2实用教程》这本书中的版本为JDK 16。\n\n JRE是什么？\nJRE（Java Runtime Environment，Java运行环境），**包含JVM标准实现及Java核心类库。**JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器）\n\n JVM是什么?\nJVM（Java Virtual Machine，Java虚拟机）是一个可执行Java字节码的虚拟机进程，用于解释编译后的字节码文件(.class)。\n可以把JVM类比成一台只针对Java程序的PC虚拟机，**在Java的世界中，JVM的地位就像一台PC机器。**正因如此，Java才能够实现”一次编译，到处运行“。\n\n 三者关系\n\nJDK是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。\nJRE是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。\nJVM是整个java实现跨平台的最核心的部分，能够运行以Java语言写的程序。\n\n Java基础知识\n\n引用贯穿Java始终，Java中的“指针”就是引用\n\n 文件扩展名\n\njava源文件扩展名为.java\n编译java源文件得到的字节码文件扩展名为.class\njavac.exe是java编译器\n\n\n 主类\n\n主类：类的名字和文件名一致，并且包含main函数的类，主类是程序的入口。\n\n\njava源文件是由若干个书写形式相互独立的类组成\njava源文件中可以有多个类，可以没有主类\n如果源文件中有多个类，最多有一个是public类，也可以没有 public类\njava中如果有主类，不一定是public类\njava 应用程序必须要有主类，但是可以不是public类\n\n\n Java注释\n\n代码注释是极其重要的。注释不仅提高了代码的可读性，也是程序代码可维护性的重要环节之一。\n\n注意：多行注释和文档注释可以嵌套单行注释，但不能嵌套多行注释和文档注释\n 单行注释\n以双斜杠“ // ”标识，只能注释一行内容。\n 多行注释\n包含着“ /* ”和“ */ ”之间，能注释多行内容。为了可读性比较好，一般首行和尾行不写注释。\n 文档注释\n包含在“ /** ”和“ */ ”之间，也能注释多行内容，一般用在类、方法和变量上面，用来描述其作用。\n注释内容可以被JDK提供的工具 Javadoc 所解析，生成一套以HTML文件形式体现的该程序的说明文档，一般写在类前。\n\n Java常量\n在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：\nfinal double PI = 3.1415926;\n虽然常量名也可以用小写，但为了便于识别，通常使用大写字母，单词之间下划线隔开表示常量。例如:\nfinal int MAX_VALUE = 520;\nbyte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。\n当使用字面量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制，例如：\nint decimal = 100;int octal = 0144;int hexa =  0x64;\n\n Java转义字符\n\n\n\n符号\n字符含义\n\n\n\n\n\\n\n换行 (0x0a)\n\n\n\\r\n回车 (0x0d)\n\n\n\\f\n换页符(0x0c)\n\n\n\\b\n退格 (0x08)\n\n\n\\0\n空字符 (0x0)\n\n\n\\s\n空格 (0x20)\n\n\n\\t\n制表符\n\n\n\\\"\n双引号\n\n\n\\’\n单引号\n\n\n\\\n反斜杠\n\n\n\\ddd\n八进制字符 (ddd)\n\n\n\\uxxxx\n16进制Unicode字符 (xxxx)\n\n\n\n\n Java反编译\n\n将class文件转换成java文件\n\n语法格式：\njavap filename.java\n Java基础语法\n\n对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n类：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n方法：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。\n\n\n\n\n 基本语法\n大小写敏感：标识符Hello不同于hello\n类名：类名应遵循“帕斯卡命名法”，即如果类名由多个单词组成，那么每个单词的首字母应该大写，例如HelloWorld。\n方法名：方法名应遵循“驼峰命名法”，即如果类名由多个单词组成，那么第一个单词首字母小写，其他单词首字母大写，例如helloWorld。\n源文件名：源文件名必须和主类类名相同。\n主方法入口：所有的Java程序都从public static void main(String[] args)方法开始执行。\n\n Java标识符\n\n类名、变量名以及方法名都被称为标识符。\n\n\n首字符必须是字母，美元符号（$）或下划线（_）\n首字符之后可以是字母，美元符号（$）、下划线（_）或数字的任意组合\n关键字不能用作标识符\n\n\n Java修饰符\n\n访问控制修饰符 : default, public , protected, private\n非访问控制修饰符 : final, abstract, static, synchronized\n\n\n Java关键字\n\n关键字不能用于常量、变量和任何标识符的名称。\n\nJava关键字可在Java API文档中查询。\n Java数据类型\n\nJava 的两大数据类型:\n\n基本数据类型\n引用数据类型\n\n\n 基本数据类型\nJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\n\n\n\n数据类型\n默认值\n大小\n表示范围\n\n\n\n\nbyte\n0\n1字节\n-128(-2^7) ~ 127(2^7-1)\n\n\nshort\n0\n2字节\n-32768(-2^15) ~ 32767(2^15-1)\n\n\nint\n0\n4字节\n-2,147,483,648(-2^31) ~ 2,147,483,647(2^31-1)\n\n\nlong\n0L\n8字节\n-9,223,372,036,854,775,808(-2^63) ~ 9,223,372,036,854,775,807(2^63-1)\n\n\nfloat\n0.0f\n4字节\n遵循 IEEE 754（二进制浮点数算术标准），取值范围是无限的\n\n\ndouble\n0.0d\n8字节\n遵循 IEEE 754（二进制浮点数算术标准），取值范围是无限的\n\n\nboolean\nfalse\n1比特\ntrue、false\n\n\nchar\n‘\\u0000’\n2字节\n‘\\u0000’（0）~  ‘\\uffff’（65,535）\n\n\n\n\n 引用数据类型\n\n数组，类，接口被称为引用数据类型，共同特点是，他们的字面值并不是一个“值”而是一段地址。\n\n\n\n\n数据类型\n默认值\n\n\n\n\n数组\nnull\n\n\n类\nnull\n\n\n接口\nnull\n\n\n\n\n 注意事项\n\n浮点数不能用来表示精确的值，如货币。\nJava的整型常量默认为int型，声明long型常量，须后加‘l’或‘L’\nlong型的\"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩，所以最好大写。\nJava的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’\n将较小字节同类数据类型赋值给较大字节同类数据类型是可以的，反之需要用到强制转换\n布尔型与C/C++不同，其关键字为boolean，且只有true和false两个取值，不能赋值1表示true。\nchar类型是一个单一的16为Unicode字符\nString类型，String是项目中必不可少且使用最多的数据类型，它属于引用数据类型中“类”的范畴。\n一个引用变量可以用来引用任何与之兼容的类型。\n\n\n Java类型转换\n\nJava是一门强类型语言\n\nJava中的类型转换分为自动类型转换和强制类型转换。\n 自动类型转换\n整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。\n把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。\n 强制类型转换\n强制类型转换是大范围的数据类型转为小范围的数据类型时进行强制类型转换，需要自己去操作。\n强制类型转换格式：\n目标数据类型 变量名 = （目标数据类型）值或变量;\n 注意事项\n\nboolean类型不能与其他基本数据类型相互转换\n整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。\n转换过程中可能导致溢出或损失精度。\n小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。\n\n Java变量类型\nJava语言支持的变量类型有：\n\n局部变量：类的方法中的变量。\n实例变量：独立于方法之外的变量，不过没有 static 修饰。\n类变量：独立于方法之外的变量，用 static 修饰。\n\n 局部变量\n\n局部变量声明在方法、构造方法或者语句块中；\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；\n访问修饰符不能用于局部变量；\n局部变量只在声明它的方法、构造方法或者语句块中可见；\n局部变量是在栈上分配的。\n局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。\n\n\n 实例变量\n\n实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n当一个对象被实例化之后，每个实例变量的值就跟着确定；\n实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n实例变量可以声明在使用前或者使用后；\n访问修饰符可以修饰实例变量；\n实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。\n\n\n 类变量（静态变量）\n\n类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。\n无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。\n静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。\n静态变量在第一次被访问时创建，在程序结束时销毁。\n与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n静态变量可以通过：ClassName.VariableName的方式访问。\n类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。\n\n\n 注意事项\n每个变量都有类型，类型可以是基本类型，也可以是引用类型\n变量名必须是合法的标识符，命名遵守驼峰命名法\n避免使用单个字符当作变量名\n Java运算符\n我们可以把运算符分成以下几组：\n\n算术运算符\n关系运算符\n位运算符\n逻辑运算符\n赋值运算符\n其他运算符\n\n\n 算术运算符\n\n\n\n运算符\n含义\n\n\n\n\n+\n求和\n\n\n-\n相减\n\n\n*\n乘积\n\n\n/\n商\n\n\n%\n求余数（求模）\n\n\n++\n自加一\n\n\n–\n自减一\n\n\n\n**注意：**当出现在变量前时，会先自加一，在做赋值运算；当出现在变量后时，会先做赋值运算，再自加一。–运算符同理\n\n 关系运算符\n\n\n\n运算符\n含义\n\n\n\n\n&gt;\n大于\n\n\n&gt;=\n大于等于\n\n\n&lt;\n小于\n\n\n&lt;=\n小于等于\n\n\n==\n等于\n\n\n!=\n不等于\n\n\n\n注意：所有的关系运算符的运算结果都是布尔类型，不是true就是false，不可能是其他值。\n\n 位运算符\n\n基于二进制计算\n\n\n\n\n运算符\n含义\n例子\n\n\n\n\n＆\n如果相对应位都是1，则结果为1，否则为0\n（A＆B），得到12，即0000 1100\n\n\n|\n如果相对应位都是 0，则结果为 0，否则为 1\n（A | B）得到61，即 0011 1101\n\n\n^\n如果相对应位值相同，则结果为0，否则为1\n（A ^ B）得到49，即 0011 0001\n\n\n〜\n按位取反运算符翻转操作数的每一位，即0变成1，1变成0。\n（〜A）得到-61，即1100 0011\n\n\n&lt;&lt;\n按位左移运算符。左操作数按位左移右操作数指定的位数。\nA &lt;&lt; 2得到240，即 1111 0000\n\n\n&gt;&gt;\n按位右移运算符。左操作数按位右移右操作数指定的位数。\nA &gt;&gt; 2得到15即 1111\n\n\n&gt;&gt;&gt;\n按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。\nA&gt;&gt;&gt;2得到15即0000 1111\n\n\n\n\n 逻辑运算符\n\n\n\n运算符\n含义\n结果\n\n\n\n\n&amp;\n逻辑与（可以翻译成并且）\n两边都是true，结果才是true\n\n\n│\n逻辑或（可以翻译成或者）\n有一边是true，结果就是true\n\n\n!\n逻辑非（取反）\n!true = false、!false = true\n\n\n&amp;&amp;\n短路与\n两边都是true，结果才是true\n\n\n││\n短路或\n有一边是true，结果就是true\n\n\n\n 短路与&amp;&amp; 和 逻辑与&amp;的区别\n两个运算符的运算结果没有任何区别\n“短路与&amp;&amp;”运算符会发生短路现象，即当左侧表达式为false时，不再执行判断右侧表达式。例如：\nboolean left = false;boolean right = true;System.out.println(left &amp;&amp; right);\n因此从效率方面来说，&amp;&amp;比&amp;的效率高一些。因为逻辑与&amp;不管左侧表达式结果是什么，第二个表达式一定会执行。\n短路或|| 和 逻辑或|同理\n\n 赋值运算符\n\n\n\n操作符\n描述\n例子\n\n\n\n\n=\n赋值\nC = A + B将把A + B得到的值赋给C\n\n\n+=\n加等\nC + = A等价于C = C + A\n\n\n-=\n减等\nC - = A等价于C = C - A\n\n\n*=\n乘等\nC * = A等价于C = C * A\n\n\n/=\n除等\nC / = A，C 与 A 同类型时等价于 C = C / A\n\n\n%=\n模等\nC％= A等价于C = C％A\n\n\n&lt;&lt;=\n左移位赋值运算符\nC &lt;&lt; = 2等价于C = C &lt;&lt; 2\n\n\n&gt;&gt;=\n右移位赋值运算符\nC &gt;&gt; = 2等价于C = C &gt;&gt; 2\n\n\n&amp;=\n按位与赋值运算符\nC＆= 2等价于C = C＆2\n\n\n^=\n按位异或赋值操作符\nC ^ = 2等价于C = C ^ 2\n\n\n|=\n按位或赋值操作符\nC | = 2等价于C = C | 2\n\n\n\n\n 其他运算符\n 条件运算符（三目运算符）\n该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。\nvariable x = (expression) ? value if true : value if false\n 字符串连接运算符（+）\n+运算符再Java中有两个作用：\n\n求和\n字符串拼接\n\n当+运算符两边都是数值类型时，执行求和操作\n当+运算符任意一边为字符串类型，则执行拼接操作，例如：\nint a = 520;String s = \"我爱你\";System.out.println(a + s); //520我爱你\n instanceof 运算符\n该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。\ninstanceof运算符使用格式如下：\n( Object reference variable ) instanceof  (class/interface type)\n如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。例如：\nString name = \"James\";boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真\n Java输入、输出数据\n 输入方法\n Scanner类\n\n使用Scanner类，首先需要导入java.util.Scanner包\n\nimport java.util.Scanner;\n\n创建一个Scanner对象\n\nScanner reader = new Scanner(System.in);\n\nScanner类对象的方法如下：\n\n\n\n\n方法\n描述\n\n\n\n\nnextInt()\n从用户读取int值\n\n\nnextFloat()\n从用户读取float值\n\n\nnextBoolean()\n从用户读取boolean值\n\n\nnextLine()\n从用户读取一行文本\n\n\nnext()\n从用户那里读取一个单词\n\n\nnextByte()\n从用户读取byte值\n\n\nnextDouble()\n从用户读取double值\n\n\nnextShort()\n从用户读取short值\n\n\nnextLong()\n从用户读取long值\n\n\n\n如要输入一个int型整数，使用方法如下：\nreader.nextInt();\n\n 输出方法\n System.out.println()\n\n换行输出\n\nSystem.out.println('z');System.out.println('c');\n运行结果：\nzc\n System.out.print()\n\n不换行输出\n\nSystem.out.print('z');System.out.print('c');\n运行结果：\nzc\n System.out.printf()\n\n格式化输出，和c语言的printf()类似\n\nSystem.out.printf(\"%s\\n\",\"lzc\");\n运行结果：\nlzc\n Java选择结构\n if条件分支语句\n if语句\nif(布尔表达式) {    //如果布尔表达式为true将执行的语句}\n if……else语句\nif(布尔表达式) {    //如果布尔表达式为true将执行的语句}else {\t//如果布尔表达式为false将执行的语句}\n if……else if……else语句\nelse if可以有若干个\nif(布尔表达式1) {    //如果布尔表达式1为true将执行的语句}else if(布尔表达式2) {\t//如果布尔表达式2为true将执行的语句}else {\t//如果以上布尔表达式都为false将执行的语句}\n\n switch开关语句\nswitch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n语法：\nswitch(表达式) {    case 常量值1 :       //语句       break; //可选    case 常量值2 :       //语句       break; //可选    //你可以有任意数量的case语句    default : //可选       //语句}\nswitch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。\nswitch case 语句有如下规则：\n\nswitch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。\nswitch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。\ncase 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。\n当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。\n当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。\nswitch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。\n\n Java循环结构\n for循环\n语法格式：\nfor(初始化; 布尔表达式; 更新) {    //代码语句}\nJava5 引入了一种主要用于数组的增强型 for 循环。\nJava 增强 for 循环语法格式如下:\nfor(声明语句 : 表达式) {   //代码句子}\n**声明语句：**声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n**表达式：**表达式是要访问的数组名，或者是返回值为数组的方法。\n\n while循环\n语法格式：\nwhile( 布尔表达式 ) {  //循环内容}\n只要布尔表达式为 true，循环就会一直执行下去。\n\n do…while循环\n语法格式：\ndo {       //代码语句}while(布尔表达式);\ndo…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。\n\n break关键字\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n语法：\nbreak;\n\n continue关键字\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n语法：\ncontinue;\n Java数组\n\nJava 语言中提供的数组是用来存储固定大小的同类型元素。\n\n 声明数组\n声明数组有两种格式\ndataType[] arrayRefVar; \ndataType arrayRefVar [];\n注意: 建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。\n声明二维数组，则两个方括号：\ndataTepy [][] arrayRefVar;\n\n 创建数组\n\nJava语言使用new操作符来创建数组\n\n语法格式：\narrayRefVar = new dataType[arraySize];\n数组变量的声明，和创建数组可以用一条语句完成，如下所示：\ndataType[] arrayRefVar = new dataType[arraySize];\nJava中的数组索引从0开始，索引值从0到arrayRefVar.length - 1\n\n 处理数组\n数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 For-Each 循环。\n For-Each循环\nJDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。\n语法格式如下：\nfor(type element: array) {    System.out.println(element);}\n例如：\ndouble[] myList = {1.9, 2.9, 3.4, 3.5};// 打印所有数组元素for (double element: myList) {\tSystem.out.println(element);}\n Java类和对象\n\n类和对象是面向对象编程（Object Oriented Programming）中最基础的组成单元。\n\n 类和对象的基本概念\n类：是抽象的概念集合，表示的是一个共性的产物，类之中定义的是属性和行为（方法）。\n对象：对象是一种个性的表示，表示一个独立的个体，每个对象拥有自己独立的属性，依靠属性来区分不同对象。\n类是对象的模板，对象是类的实例。类只有通过对象才能使用，先产生类再产生对象。类不能直接使用，对象是可以直接使用的。\n\n 类和对象的定义和使用\n在Java中定义类需要使用class关键字。语法如下：\nclass &lt;class_name&gt; {\tfield;\t//成员属性（变量）\tmethod;\t//成员行为（方法）}\n例如创建一个Person类\nclass Person {\tString name;\t//姓名\tint age;\t//年龄\tpublic void show() {\t//显示这个对象的信息\t\tSystem.out.println(\"姓名：\" + name + \"年龄：\" + age);\t}}\n类定义好以后要依靠对象来使用，由于类属于引用数据类型，那么对象的产生格式如下：\n&lt;class_name&gt; &lt;对象名&gt; = new &lt;class_name&gt;();\n或\n&lt;class_name&gt; &lt;对象名&gt; = null;&lt;对象名&gt; = new &lt;class_name&gt;();\n引用数据类型与基本数据类型最大的不同在于：引用数据类型需要内存的分配和使用。所以，关键字new的主要功能就是分配内存空间，也就是说，只要使用引用数据类型，就要使用关键字new来分配内存空间。\n当一个实例化对象产生之后，可以按照如下的方式进行类的操作：\n对象.属性：表示调用类之中的属性；\n对象.方法()：表示调用类之中的方法。\n例如：\nPerson lzc = new Person();lzc.show(); //访问该对象的show方法\n\n 成员变量与局部变量\n\n成员变量：类中方法外的变量\n局部变量：方法中的变量\n\n\n\n\n区别\n成员变量\n局部变量\n\n\n\n\n类中位置\n类中方法外\n类中方法内\n\n\n内存中位置\n堆内存\n栈内存\n\n\n生命周期\n与对象的生命周期相关\n与方法的生命周期相关\n\n\n初始化值\n有默认初始化值\n无默认初始化值，先定义赋值在使用\n\n\n\n成员变量的默认初始化值：\n基本数据类型符合其默认值规则\n引用数据类型默认值为null\n\n this关键字\nthis修饰的变量用于指代成员变量\nclass Person {\tprivate String name;\t//姓名\tprivate int age;\t//年龄 成员变量\tpublic void setAge(int age) {\t\tthis.age = age; //this使其指向成员变量\t}}\n\n 方法\n 定义\n方法的定义包括两部分：方法头和方法体。\n一般格式为：\n访问修饰符 返回数据类型 方法名 (形参列表) {\t语句;    return 返回值;}\n**访问修饰符：**作用是控制方法的使用范围，有四种（public,protected,default,private），不写访问修饰符时，默认为public。\n**返回数据类型：**可以为任意类型，包含基本类型或引用类型（数组、对象）。如果方法要求有返回数据类型，则方法体中最后的return的值必须和返回数据类型一致或兼容。\n**方法名：**遵循驼峰命名法，见名知义。\n 方法的调用\n 样例代码\nclass A {\tpublic void sayHello() {\t\tSystem.out.println(\"Hello\");\t}\tpublic void sayBye() {\t\tSystem.out.println(\"Bye\");\t}}class B {\tpublic void sayOk() {\t\tSystem.out.println(\"Ok\");\t}}\n 同类调用\n同一个类中的方法调用，直接调用即可。\n如类A中的sayBye方法要调用同类的sayHello方法，则调用方法如下：\npublic void sayBye() {\tsayHello();\tSystem.out.println(\"Bye\");}\n 跨类调用\n跨类中的方法调用，需要通过对象名调用。\n如类B中的sayOk()方法要调用类A中的sayHello方法，则调用方法如下：\npublic void sayOk() {\tA tempA = new A();\ttempA.sayHello();\tSystem.out.println(\"Ok\");}\n 参数传递\n在Java中，基本数据类型和String类作为参数传递时，都是按值传递。\n引用类型传递的是地址（传递的也是值，但是这个值是地址），所以可以通过形参影响实参。\n\n 访问权限\n 定义\n对象是否可以通过.运算符操作自己的变量或调用类中的方法。\n 访问权限分类\n\n公共类\n非公共类\n\n使用public修饰的类为公共类，反之为非公共类。\n 四种访问权限\n\nprivate\ndefault(包访问权限，一般省略)\npublic\nprotected\n\n public\n用public关键字修饰的成员变量和成员方法称为共有变量和共有方法。\n被public修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。\n protected\n用protected关键字修饰的成员变量和成员方法成为受保护的成员变量和受保护的成员方法。\n被protected修饰的类、属性以及方法只可跨类访问，不允许跨包访问。\n 友好（default默认权限）\n不用private,public,protect关键字修饰的成员变量和方法成为友好变量和友好方法。\n下面这个add()方法就是友好方法\nint add(int a,int b) {\treturn a + b;}\n在同一个包中，一个类中的友好变量和友好方法，在另一个类中通过类名来操作这个成员变量和调用方法。在不同包中，如果源文件用import语句引入另一个包中的类，并使用该类创建了一个对象，那么该类的对象将不能访问自己的友好变量和友好方法。\n private\n用private关键字就是的成员变量和成员方法称为私有变量和私有方法。\n被private修饰的成员变量和成员方法只能在本类中使用。\n如果需要被别的类使用，则需用通过方法来返回值\nclass Person {\tprivate String name;\t//姓名\tprivate int age;\t//年龄\tpublic String getName() {\t\treturn name;\t//通过方法返回name\t}\tpublic int getAge() {\t\treturn age;\t//通过方法返回age\t}}\n 四种访问权限差异表\n\n\n\n访问权限\n同类\n同包\n子类\n非子类的外包类\n\n\n\n\npublic\n√\n√\n√\n√\n\n\nprotected\n√\n√\n√\n×\n\n\ndefault\n√\n√\n×\n×\n\n\nprivate\n√\n×\n×\n×\n\n\n\n\n 方法重载\n\n重载(overloading)是在同一个类中，名同参数不同。\n\n每个重载的方法（或构造函数）都必须有不同的参数类型列表。\n重载是面向对象的一个基本特性。\n说明：\n\n方法名相同\n方法的参数类型列表不同\n方法的返回值可以不相同\nmain方法可被重载\n声明为final的方法不能被重载\n声明为static的方法不能被重载，但可被声明\n\n具体实例：\nclass Lzc {\tvoid add() {\t//无返回值无参数类\t\tSystem.out.println(\"76\");\t}\tvoid add(int a) {\t//重载上面的无返回值无参数类，无返回值一个形参的类\t\tSystem.out.println(a + 20);\t}\tint add(int a,int b) {\t//重载上面的类，有返回值两个形参的类\t\treturn a + b;\t}}\n在主方法中执行以下代码时\nLzc t = new lzc();t.add();t.add(70);System.out.println(t.add(10,57));\n程序输出结果：\n76\t//\"L\"90\t//\"Z\"67\t//\"C\"\n重载分辨：方法名称相同时，编译器会自动根据相应的调用方法，去选择对应的方法，如果匹配失败，则报错。\n 封装\n\n面向对象三大特性：封装、继承和多态\n\n封装的好处：保护性和易用性\nprivate实现属性和方法的封装只是封装的一种。、\nprivate:私有的，被private修饰的属性和方法，只在当前类的内部可见，出了类的{}，对外部就完全隐藏了，外部不知道有其存在。\npublic：公共的，公开的，被public修饰的东西，在当前程序(项目)中都是可见的，都是可以使用的。\n 封装原则\n将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。\n例如成员变量private，提供对应的方法。\n\n 上转型对象和下转型对象\n\n上转型对象：子类转父类\n下转型对象：父类转子类\n基于继承。\n\n 上转型对象\nA a = new B(); //B是A的子类\n称a为子类对象b的上转型对象。\n\n上转型对象不能操作子类声明定义的成员变量、成员方法。\n上转型对象可以访问子类继承或隐藏的成员变量，可以使用子类继承或重写的方法。\n将上转型对象再强制转换成子类对象，就恢复成子类对象，相应的属性和方法随之恢复。\n如果子类重写了父类的某个方法，上转型对象调用的是重写的方法。\n\n上转型是父类的引用指向了子类的对象，所以它指向的是父类应该拥有的属性和方法。\n 下转型对象\n如果直接使用下转型\nB b = new A(); //B是A的子类\n会出错的。\n因为向下转型，父类不具有子类的方法。\n但是可以对上转型对象进行下转型，这类似于+1-1的过程。\n 为什么要用上转型对象\n方便面向接口的编程思想和面向抽象的编程思想，实现了方法的多态，降低了程序之间关联性。\n Java包\n 包的概念\n包（package）是一种组织类的方式，使用包的主要目的是保证类的唯一性。\nJava程序中，为了开发方便，会将功能相似的类放入一个文件夹中，这个文件结构就是包。\n\n 引入类库中的包（import语句）\nimport语句：引入包中的类\nimport 包名.包中的类;\t//引入某个包中具体的某个类import 包名.*;\t//引入某个包中所有的类\n Java String类\n\n字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。\n\n 前言\n\nString表示字符串类型，属于 引用数据类型 ，不属于基本数据类型。\n在java中随便使用 双引号括起来 的都是String对象。\nC语言中没有字符串这种数据类型，只有字符数组。\nC中既包括C语言的字符数组（C风格字符串），也有C引入的string类型（‘s’小写）。\nJava中，有String类型（‘S’大写），String类型不属于8大基本类型。\n\n\n 创建字符串\nString str = \"love\";\n在代码中遇到字符串常量时，这里的值是 “love”，编译器会使用该值创建一个 String 对象。\n和其他对象一样，可以使用关键字和构造方法来创建String对象。\nString str = new String(\"love\");\n\n 字符串方法\n\n\n\n方法名\n作用\n\n\n\n\ncharAt(int index)\n返回指定位置的字符\n\n\ncompareTo(String anotherString)\n比较两个字符串。相等返回0；前大后小返回1；前小后大返回-1\n\n\ncontains(CharSequence s)\n判断字符串是否包含s\n\n\nendsWith(String suffix)\n判断字符串是否以suffix结尾\n\n\nequals(Object anObject)\n判断两个串是否相等\n\n\nequalsIgnoreCase(String anotherString)\n忽略大小写判断两个串是否相等\n\n\ngetBytes()\n将字符串串变成字节数组返回\n\n\nindexOf(String str)\n返回str在字符串第一次出现的位置\n\n\nisEmpty()\n字符串是否为空\n\n\nlength()\n字符串长度\n\n\nlastIndexOf(String str)\n返回str最后一次出现的位置\n\n\nreplace(CharSequence target, CharSequence replacement)\n用replacement替换字符串target的字符\n\n\nsplit(String regex)\n将字符串以regex分割\n\n\nstartsWith(String prefix)\n判断字符串是否以prefix开始\n\n\nsubstring(int beginIndex)\n从beginIndex开始截取字串\n\n\nsubstring(int beginIndex, int endIndex)\n截取beginIndex到endIndex - 1的字符串\n\n\ntoCharArray()\n将字符串转换乘char数组\n\n\ntoLowerCase()\n字符串转小写\n\n\ntoUpperCase()\n字符串转大写\n\n\ntrim()\n去除字符串两边空格\n\n\n静态方法\n\n\n\nvalueOf(int i)\n将 i 转换成字符串\n\n\n\n\n 关于字符串匹配 == 和 equals() 的区别\n ==\n\n比较的是地址\n\n在比较**引用类型（除了String）**时，只要不是同一个对象，就不是同一个地址。String类型new两个对象，也不是同一个地址。\n equals()\n\nString中比较的是值\n\n在比较引用类型（除了String）时，使用的是object中的equals方法，比较的是地址是否一样。\n但是String类重写了Object中的equals方法，依次比较顺序如下：\n\n地址\n类型\n值（内容）\n\nequals()语法如下：\nstr1.equals(str2);\n 正则表达式\n\n正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为\"元字符\"）。\n\n 用途\n\n匹配：判断给定的字符串是否符合正则表达式的规则逻辑\n替换：对给定的字符串按指定的规则进行替换\n检验程序员水平\n\n\n 正则表达式与元字符\n一个正则表达式是含有一些具有特殊意义字符的字符序列。\n这些特殊字符称作正则表达式中的元字符。\n例如,\\\\dhello中的\\\\d就是有特殊意义的元字符，代表一位数字。字符序列9hello、3hello都是与之匹配的字符序列之一。\n\n 正则表达式语法\n 元字符\n 转义字符\"\\\"\n在Java的正则表达式中，两个\\\\代表其他语言中的一个\\，这也就是为什么表示一位数字的正则表达式为\\\\d，而表示一个普通的反斜杠是\\\\。\n\n 字符匹配符\n\n\n\n字符\n含义\n示例\n匹配输入\n\n\n\n\n[]\n字符集，可接收字符列表\nj[abc]va\njava\n\n\n[^]\n反向字符集，不可接收字符列表\nj[^bcd]va\njava\n\n\n-\n连字符，字符范围\nj[a-z]va\njava\n\n\n.\n匹配除\\n以外的任何单个字符\nj.va\njava\n\n\n\\d\n数字字符匹配，相当于[0-9]\n\\d{3}java\n520java\n\n\n\\D\n非数字字符匹配，相当于[^0-9]\n\\D\njava520\n\n\n\\w\n匹配任何字类字符，包括下划线，相当于[A-Za-z0-9_]\n\\d{3}\\w{4}\n520java\n\n\n\\W\n与任何非单词字符匹配，相当于[^A-Za-z0-9_]\n\\W{3}\\w{4}\n@#!java\n\n\n\\s\n匹配任何空白字符，包括空格、制表符、换页符等，相当于[\\f\\n\\r\\t\\v]\nja\\sva\nja va\n\n\n\\S\n匹配任何非空字符，相当与[^\\f\\n\\r\\t\\v]\nja\\Sva\njava\n\n\n\n\n 选择匹配符\n\n\n\n符号\n含义\n示例\n匹配输入\n\n\n\n\n|\n或。|两侧的表达式存在或的关系\nab|bc\nab和bc\n\n\n\n\n 限定符\n\n\n\n符号\n含义\n示例\n匹配输入\n\n\n\n\n*\n零次或多次匹配前面的字符或子表达式\na*\naa、abc、bc\n\n\n+\n一次或多次匹配前面的字符或子表达式\na+\naa、abc\n\n\n？\n零次或一次匹配前面的字符或子表达式\na?\nbc、abc\n\n\n{n}\nn是非负整数，正好匹配n次\n[abc]{2}\naa、ab、bc\n\n\n{n,}\nn是非负整数，至少匹配n次\n[abc]{2}\nabc、abcd\n\n\n{n,m}\nn和m是非负整数，n≤\\le≤m。至少匹配n次，至多匹配m次\n[abc]{1,2}\na、ab、b\n\n\n?\n当此字符紧随任何其他限定符之后时，匹配模式时非贪心的\n\n\n\n\n\n注意：Java的匹配基于贪心思想，当有符合最长的匹配时，会优先匹配最长的。例如在字符串aaaa中，a+会匹配aaaa，a+?会匹配a。\n\n 定位符\n\n\n\n符号\n含义\n示例\n匹配输入\n\n\n\n\n^\n指定起始字符\n[1]+[a-z]*\n1a、12ab、520java\n\n\n$\n指定结束字符\n[2]+[a-z]$\n520j、12a\n\n\n\\b\n匹配目标字符串的边界\nva\\b\njava\n\n\n\\B\n匹配目标字符串的非边界\nav\\B\njava\n\n\n\n 分组\n 捕获分组\n\n\n\n常用分组构造形式\n说明\n\n\n\n\n(pattern)\n非命名捕获。捕获匹配的字符串，编号为0的第一个捕获是由整个正则表达式模式匹配的文本，其他捕获结果则根据左括号的顺序从1开始自动编号\n\n\n(?pattern)\n命名捕获。将匹配的字符串捕获到一个组名称或者编号名称中，用于name的字符串不能包含任何标点符号，并且不能以数字开头，可以使用单引号替代尖括号，例如(?'name’pattern)\n\n\n\n 非捕获分组\n\n\n\n常用分组构造形式\n说明\n\n\n\n\n(?:pattern)\n匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用\"or\"字符 (|) 组合模式部件的情况很有用。例如，'industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。\n\n\n(?=pattern)\n执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，‘Windows (?=95|98|NT|2000)’ 匹配\"Windows 2000\"中的\"Windows\"，但不匹配\"Windows 3.1\"中的\"Windows\"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\n\n\n(?!pattern)\n执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，‘Windows (?!95|98|NT|2000)’ 匹配\"Windows 3.1\"中的 “Windows”，但不匹配\"Windows 2000\"中的\"Windows\"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\n\n\n\n\n 常用正则表达式\n\n\n\n要求\n规则\n表达式\n\n\n\n\n汉字字符串\n用16制编码范围来表示\n[3]+$\n\n\n邮政编码\n以1-9开头的六位数字\n[4]\\d{5}$\n\n\nQQ号\n以1-9开头的5-10位数字\n[5]\\d{4,9}$\n\n\nURL\n\n\"^((http\n\n\n电子邮箱\n只能有一个@，以a-zA-Z0-9-_开头，以com、cn等结尾\n[6]+@([a-zA-Z].)+[a-zA-Z]+$\n\n\n\n\n Java子类与继承\n 子类\n\n由继承的得到的类\n\n子类继承一般类的属性和行为，并且可根据需要在子类中添加新的属性和行为。\nJava不支持多重继承，子类只能有一个父亲。子类和父类的关系称为is-a关系。\n在类的声明中，通过使用关键字extends 来定义一个类的子类，格式:\nclass 子类名 extends 父类名 {}\n 类的树形结构\nJava的类按继承关系形成树形结构，根节点是Object类（Object是java.lang包中的类），即Object是所有类的祖先类。\n每个类（除了Object类）有且仅有一个父类，可以有多个或零个子类。\n如果进行类声明时没有使用extends关键字，则默认为Object的子类。\n 子类的继承性\n\n继承家产\n\n子类和父类的继承性分为同包和不同包。\n 子类和父类在同包中的继承性\n若子类和父类在同一个包中，子类可以继承父类中除了private的成员变量、方法作为自己的成员变量、方法。\n不想被子孙继承的家产就用private修饰\n 子类和父类在不同包中的继承性\n若子类和父类在不同包中，子类可以继承父类中除了private和友好访问权限成员变量、方法作为自己的成员变量、方法。\n（不用private、public和protected修饰的就是友好访问权限）\n 关于protected的进一步说明\n一个类中的protected成员变量和方法可以被它的子孙类继承，但是需要继承下来的这个成员变量或方法所在的类和访问它的这个类在同一个包中。\n可以把一个继承了很多次类看成一个家族，有很多代人，每代人都有可能移居不同的地方，把成员变量和方法看成固定资产。当这个家族到我这一代时，我可以继承这个家族在这个地方留下的资产，但是那些移居外地的祖先的固定资产，与我无关。\n 子类与对象\n当用子类的构造方法创建了一个子类的对象时，子类和父类中声明的成员变量都被分配了内存空间，包括不被子类继承的父类中的private成员变量。\n虽然无法直接操纵父类的private成员变量，但是可以通过从父类继承下来的方法来对这些父类的private成员变量进行操纵。\ninstanceof运算符是Java独有的双目运算符，左边是对象，右边是类，用来确定对象是否为右边类的子类。\n对象名 instanceof 类名 //true or false\n 上转型对象和下转型对象\n\n上转型对象：子类转父类\n下转型对象：父类转子类\n基于继承。\n\n 上转型对象\nA a = new B(); //B是A的子类\n称a为子类对象b的上转型对象。\n\n上转型对象不能操作子类声明定义的成员变量、成员方法。\n上转型对象可以访问子类继承或隐藏的成员变量，可以使用子类继承或重写的方法。\n将上转型对象再强制转换成子类对象，就恢复成子类对象，相应的属性和方法随之恢复。\n如果子类重写了父类的某个方法，上转型对象调用的是重写的方法。\n\n上转型是父类的引用指向了子类的对象，所以它指向的是父类应该拥有的属性和方法。\n 下转型对象\n如果直接使用下转型\nB b = new A(); //B是A的子类\n会出错的。\n因为向下转型，父类不具有子类的方法。\n但是可以对上转型对象进行下转型，这类似于+1-1的过程。\n 为什么要用上转型对象\n方便面向接口的编程思想和面向抽象的编程思想，实现了方法的多态，降低了程序之间关联性。\n\n Java抽象类\n由abstract修饰的类、方法叫抽象类、抽象方法。因为这种类是抽象的、理论上的，所以它不能进行实例化。\n抽象类除了不能实例化对象，它作为类的其他功能依然存在，成员变量、成员方法和构造方法等和普通类一样。\n在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类可以实现多个接口。\nabstract class 类名 { //抽象类\t//成员变量\t//成员方法\tabstract void 方法名(); //抽象方法没有方法体}\n\n继承抽象类的对象，都必须实现这个抽象方法。\n只有抽象类才能包含抽象方法。\n\n继承抽象类的方法和继承普通类一样，在类名后面加extends\npublic class 子类 extends 父类 {\t//成员变量\t//成员方法}\n总结\n\n抽象类不能被实例化\n抽象类中不一定包含抽象方法，但是由抽象方法的类必定是抽象类\n抽象方法只声明，不包含方法体\n构造方法，类方法（用static修饰的方法）不能声明为抽象方法\n抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。\n抽象类能继承抽象类\n\n Java接口\n\n接口制定标准\n\n 概念\n接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现具有不同的行为。\n接口是解决Java无法使用多继承的一种手段。\n接口是一种特殊的抽象类，是由全局常量和公共的抽象方法组成。\n 定义接口\n接口定义使用的关键字是interface，接口定义的语法格式如下：\n[public] interface 接口名 [extends 父接口]{\t//常量\t//声明方法}\n注意：一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类\n 实现接口\n接口的主要用途就是被实现类实现，一个类可以实现一个或多个接口，这解决了Java不能支持多继承的局限性。\n接口的实现使用implements关键字，类实现接口的语法格式如下：\npublic class 类名 [extends 父类] [implements 接口1，接口2...] {\t//类主体}\n END\n\n\n\n0-9 ↩︎\n\n0-9 ↩︎\n\n\\u0391-\\uffe5 ↩︎\n\n1-9 ↩︎\n\n1-9 ↩︎\n\n\\w- ↩︎\n\n\n\n","categories":["笔记"],"tags":["java"]},{"title":"JavaEE学习笔记","url":"/2023/10/27/JavaEE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":" JavaEE\n doGet() 和 doPost()\n doGet()\n维基百科定义：\n\nGET requests a representation of the specified resource.\nNote that GET should not be used for operations that cause side-effects, such as using it for taking actions in web applications. One reason for this is that GET may be used arbitrarily by robots or crawlers, which should not need to consider the side effects that a request should cause.\n\nGET请求指定资源的表示形式。\n注意，GET不应该用于产生副作用的操作，比如在web应用程序中使用它来执行操作。这样做的一个原因是，GET可能会被机器人或爬虫任意使用，它们应该不需要考虑请求应该引起的副作用。\n当浏览器使用get方式提交数据时，servlet需要提供doGet()方法。\n明文显示：doGet方法在提交表单时会在url后面显示提交的内容（不安全）。\n长度限制：doGet方法只能提交256个字符（1024字节），因为get方式数据的传输载体是URL（提交方式能form，也能任意URL链接）。\n会用到get方式的情景：\n\nform默认的提交方式\n如果通过一个超链访问某个地址\n如果在地址栏直接输入某个地址\najax指定使用get方式的时候\n\n关于GET方法还有一个称呼是幂等(idempotent)方法（无论操作多少次，结果一致）。\n doPost()\n维基百科定义：\n\nPOST submits data to be processed (e.g., from an HTML form) to the identified resource.\nThe data is included in the body of the request. This may result in the creation of a new resource or the updates of existing resources or both.\n\nPOST将待处理的数据(例如，来自HTML表单)提交给所标识的资源。\n数据包含在请求的主体中。这可能会导致创建新资源或更新现有资源，或者两者都有。\n当浏览器使用post方式提交数据的时候，servlet需要提供doPost()方法。\n用于客户端传输数据到服务器端，也会有副作用。\n隐藏数据：post方法使用表单传输，不会明文显示数据。\n长度大：POST也是有长度限制的，不是一般说的POST不限制，默认是2097152，不同的Web Server实现不同。\n会用到post方式的情景：\n\n在form上显示设置 method=\"post\"的时候\najax指定post方式的时候\n\n在servlet文件中，由service(request, response) 方法功能是判断用户发出是什么请求，如果是get则调用子类（HttpSevr）的doGet方法，如果是post则调用子类（HttpSevr）的doPost方法。\n 区别\n\nget方式采用URL跳转方式请求，post方法采用表单提交方式请求。\nget请求会有cache，post不会有cache。\nget请求会保留在浏览历史中，post不会。\nget请求可以保存到书签（本质是个URL），post不能。\nget请求长度小，post请求长度大。\nget请求应该只用于获取数据，post请求处理敏感信息。\n\n\n 隐藏域\n HTML表单隐藏域\n隐藏域是用来收集或发送信息的不可见元素，对于网页访问者来说，隐藏域是不可见的。当表单被提交时，隐藏域就会将信息用设置时定义的名称和值发送到服务器。\n 使用方法\ntype=\"hidden\"\n 用法\n一般用于隐藏不希望用户看见的信息，在提交表单时，将伴随用户提交的请求将信息传送。用于存放在表单，被提交时需要提交却不需要显示的参数值的容器。\n\n Referer——防盗链\nReferer是HTTP请求requset header的一部分，当浏览器向web服务器发送请求的时候，头信息中就包含Referer\nReferer的内容就是当前页面的上一页面。\nReferer其实是Referrer的错误拼写，发现错误时已经广泛使用，修改成本高，于是就将错就错了。\n 为什么使用Referer\nreferrer\t英/ rɪˈfɜːrə /\nnnn.推荐人，上线；介绍人\nReferer字段告诉了服务器，用户在访问当前资源之前的位置，用来用户跟踪。\n一言以蔽之，你从哪来?\n Referer的使用\nReferer是一个可选字段。\n浏览器的 JavaScript 引擎提供document.referrer属性，可以查看当前页面的引荐来源。注意，这里采用的是正确拼写。\n空Referer的定义为 Referer=\"\" || Referer=null\n当没有上一请求地址时，Referer是空。\n直接在浏览器的地址栏中输入一个资源的URL地址，这种方式请求不包含Referer。\n允许Referer为空，则允许浏览器或者重定向直接URL访问资源；\n不允许为空，则直接输入URL访问会被拦截。\n在servlet中使用：\nString referer = request.getHeader(\"Referer\");if (referer==null||\"\".equals(referer)||!referer.startsWith(\"http://localhost:8081\")) {\tresponse.sendRedirect(\"xxx.html\");\treturn;}request.getRequestDispatcher(\"xxx.html\").forward(request,response);\n\n ServletContext\nServletContext称为servlet上下文。\n服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。\n此对象全局唯一，且工程内所有servlet共享此对象，因此叫做全局应用程序共享对象\n servletContext是一个域对象\n域对象是服务器在内存上创建的存储空间，用于在不同动态资源（servlet）之间传递与共享数据。\n 读取全局配置参数\n//根据指定的参数名获取参数值getServletContext().getInitParameter(name);//获取所有参数名称列表getServletContext().getInitParameterNames();\n 搜索当前工程目录下面的资源文件\n//根据相对路径获取服务器上资源的绝对路径getServletContext().getRealPath(path);//根据相对路径获取服务器上资源的输入字节流getServletContext().getResourceAsStream(path);//获取当前工程名字getServletContext().getContextPath();\n 会话跟踪（session tracking）\n\nsession  英/ ˈseʃ(ə)n /\nn.（某项活动的）一段时间，一场；（议会等的）会议，（法庭的）开庭；学年，上课时间；（酒吧中）演奏会（尤指演奏爱尔兰音乐）；（尤指录音师的）灌录音乐时间；&lt;非正式&gt;酗酒期；基督教长老会的管理机构\nadj.（音乐家）伴奏的\n[计算机]会话\n\nHTTP是一种无连接的协议，如果客户端只是单纯请求一个文件，服务器端对其响应，无需知道一系列的请求是否来自同一客户端，也无需担心客户端是否处于连接状态，简单来说，有人请求就直接响应，服务器不会保留之前客户端请求的任何记录。\n因此这种通信协议使得服务器端难以判断所连接的客户端是否是同一个。\n当进行Web程序开发时，需要将相关的请求结合，并维持用户的状态在服务器上，因此引出会话追踪（session tracking）对同一用户对服务器的连续的请求和接受响应的监视。\n 会话跟踪技术：\n\nCookie\nSession\nURL重写\n隐藏表单域\n\n\n Cookie\n\ncookie 英/ ˈkʊki /\n*n.*曲奇饼，小甜饼；……样的人；（浏览网页后存储在计算机的）缓存文件；&lt;苏格兰&gt;淡面包；漂亮的年轻女子\n\nCookie，它的名字源自一种叫 Fortune cookie 的“幸运小饼干”，这种饼干里面有一张小纸条。\n注意：Cookie只支持Ascii字符形式并且不能跨浏览器使用。\n Cookie是什么？\n一些数据信息，类型为小型文本文件，存储于电脑上的文本文件中。\n Cookie有什么用？\n例如登陆过的网站，再次打开就会自动登录。\n浏览器保存了我们的Cookie，里面记录了一些信息，当下一次浏览器向Web服务器发送任何请求时，浏览器会把这些Cookie信息发送到服务器，服务器使用这些信息识别用户。\n Cookie怎么用？\n 创建Cookie：\npublic class CookieServletOne extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        response.setContentType(\"text/html;charset=utf-8\");        // 创建Cookie        Cookie cookie = new Cookie(\"author\",\"cicada\");        // 设置生命周期 1小时        cookie.setMaxAge(60*60);        // 将Cookie添加进Response        response.addCookie(cookie) ;        response.getWriter().print(\"Hello:Cookie\");    }}\n 获取Cookie：\npublic class CookieServletOne extends HttpServlet {    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        System.out.println(\"doPost...\");        // 创建Cookie数组接收        Cookie[] cookies = request.getCookies() ;        // 遍历接收到的Cookie        for (Cookie cookie:cookies){            System.out.println(\"Name：\"+cookie.getName());            System.out.println(\"Value：\"+cookie.getValue());        }        response.setContentType(\"text/html;charset=utf-8\");        String userName = request.getParameter(\"userName\") ;        response.getWriter().print(\"Hello:\"+userName);    }}\n 更新Cookie：\npublic class CookieServletTwo extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        response.setContentType(\"text/html;charset=utf-8\");        // 创建Cookie        Cookie cookie = new Cookie(\"author\",\"smile\");        // 设置生命周期 2小时        cookie.setMaxAge(60*60*2);        response.addCookie(cookie) ;        response.getWriter().print(\"Hello:Cookie\");    }}\n 删除Cookie：\npublic class CookieServletTwo extends HttpServlet {    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        response.setContentType(\"text/html;charset=utf-8\");        Cookie[] cookies = request.getCookies() ;        for (Cookie cookie:cookies){            if (cookie.getName().equals(\"author\")){                // 将生命改为0就表示该Cookie被作废了                cookie.setMaxAge(0);                response.addCookie(cookie);            }        }        String userName = request.getParameter(\"userName\") ;        response.getWriter().print(\"Hello:\"+userName);    }}\n Cookie相关接口\n\nsetMaxAge() ：设置cookie过期的时间，单位为秒。\ngetMaxAge() ：获取cookie的最大生命周期\ngetName() ：获取cookie的名称。名称在创建后不能改变。\ngetValue() ：获取与cookie关联的值。\nsetValue() ：设置与cookie关联的值。\n\n\n Session\n\nCookie的好兄弟\n\n session是什么?\nsession在Web应用中称为会话控制，是服务器为了保存用户状态而创建的一个对象，用于存储信息。\ncookie存储在用户端，session存储在服务器端。\n session有什么用？\n由于cookie不能存放大量数据，这时出现了一种新的技术，Session。\nsession是存储在服务器端的特殊对象，服务器会为每一个浏览器（客户端）创建一个唯一的session。\nsession是服务器端共享，每个浏览器（客户端）独享的。可以在session存储数据，实现数据共享。\n session怎么用？\n存储在服务器的数据会更加的安全，不容易被窃取，并且session比Cookie使用方便，Session可以存储对象，Cookie只能存储字符串，并且tomcat8.x之后的版本中Cookie可以存储的字符类型有限制。\n最常使用的session是javax.servlet.http.HttpSession\n 获取HttpSession对象\nHttpSession session = request.getSession(boolean create);\n得到一个HttpSession对象。\n如果当前请求不属于任何会话，并且create为true，则创建一个会话，否则返回null；如果为false，则与不带参数的形式等价。\nSession的实现依赖于Cookie\n每个Session对象都有一个唯一的JSESSIONID，会以Set-cookie响应头的形式将JSESSIONID返回给客户端，客户端再次访问的时候将JSESSIONID发送给服务器。后续请求时，服务器可通过JSESSIONID找到对应的Session对象。\n这个JSESSIONID就是SessionId\n HttpSession的方法\n如HttpServletRequest、ServletContext一样，它们都是域对象，HttpSession也是域对象，范围是当前对话。\n凡是域对象，都有如下四个操作对象的方法：\n//将value对象以name名称绑定到会话public void setAttribute(String name,Obejct value)    //获取name值，如果不存在返回nullpublic void getAttribute(String name)    //从会话中删除name属性，如果不存在不执行，不抛错public void removeAttribute(String name)    //返回与会话有关的枚举值，没有则返回空枚举public Enumeration getAttributeNames()\n其他方法：\n//使会话失效，同时删除属性对象public void invalidate()    //检测当前可会是否为新会话public Boolean isNew()    //返回会话创建时间public long getCreationTime()    //返回在会话时间内Web容器接收到客户最后发出的请求的时间public long getLastAccessedTime()    //返回在会话期间内客户请求的最长时间（秒）public int getMaxInactiveInterval()    //允许客户请求的最长时间public void setMaxInactiveInterval()    //返回当前会话的上下文环境，ServletContext对象可以使Servlet与Web容器进行通信ServletContext getServletContext()    //返回会话期间的识别号，即sessionIdpublic String getId()\n\n URL重写\n URL重写是什么？\nURL重写，是将URL重新写成Web应用可以处理的另一个URL的过程。\n它只对链接起作用，只支持文本\n它将一个或多个键值对添加到URL的查询字符串中，每个键值对为key = value形式，如:\nurl?key_1=value_1&amp;key_2=value_2...&amp;key_n=value_n\nURL和键值对之间用问好？分割，键值对之间用与符号&amp;分割。\nURL的内容会显示在浏览器的地址栏上,所以URL重写不适合用来传递敏感信息。\n URL重写有什么用？\n服务器在传递Session的ID属性时，是以Cookie的形式传递的。\n在实际应用中，如果客户端不支持Cookie或禁用Cookie功能，那么服务器就无法获取Session的ID属性，也无法获取与该客户端对应的Session对象。\n因此，URL重写技术被引入到Session机制中，在无法得知客户端是否支持Cookie时，将Session的ID属性追加到URL地址后面，从而实现会话跟踪功能。\n例如：\nhttp:localhost:8081/javaee/URLTest\n经过URL重写后变为：\nhttp:localhost:8081/javaee/URLTest;jsessionid=234A39C023E82EF\njessionid就是追加的Session ID属性\n URL重写怎么用？\nHttpServletResponse类提供了URL重写的方法：\npublic String encodeURL()    public String encodeRedirectURL()\n\n","categories":["笔记"],"tags":["javaWeb"]},{"title":"浅谈Eclipse连接MySQL","url":"/2023/10/27/Eclipse%E8%BF%9E%E6%8E%A5MySQL/","content":" 浅谈Eclipse连接MySQL\n 一、需要的工具\n\nEclipse\nMySQL\nmysql-connector-jave-版本号-bin.jar\nNavicat for MySQL\n\n 二、通过Navicat创建连接\n\n启动MySQL服务以后，打开Navicat，点击“连接”，输入连接名和密码。\n连接名在后面代码中会用到。\n\n创建好了以后，右击-打开连接，之后可以选择创建或打开数据库。\n 三、在Eclipse项目中导入jar包\n创建Java Project以后，右击这个项目，选择\"Build Path\"—“Configure Build Path…”。\n\n在打开的界面中，选择\"Librari\"—“Add External JARs”。之后选择\"mysql-connector-jave-版本号-bin.jar\"这个jar包打开，最后点击\"Apply and Close\"。\n\n至此，jar的导入就完成了。\n\n 四、写代码验证\npackage test;import java.sql.*;public class Jdbc {\tpublic static void main(String[] args) {\t\ttry {\t\t\tClass.forName(\"com.mysql.jdbc.Driver\");\t\t\tSystem.out.println(\"成功加载MySQL驱动\");\t\t} catch(Exception e) {\t\t\tSystem.out.println(\"加载MySQL驱动失败\");\t\t\te.printStackTrace();\t\t}\t\ttry {\t\t\tConnection connect = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\",\"root\",\"123\");\t\t\tSystem.out.println(\"成功连接MySQL服务器\");\t\t\tStatement stmt = connect.createStatement();\t\t\tResultSet rs = stmt.executeQuery(\"select * from goods\");\t\t\twhile(rs.next()) {\t\t\t\tString number = rs.getString(\"number\").trim();\t\t\t\tString name = rs.getString(\"name\").trim();\t\t\t\tDate date = rs.getDate(\"madeTime\");\t\t\t\tdouble price = rs.getDouble(\"price\");\t\t\t\tSystem.out.printf(\"%-5s\", number);\t\t\t\tSystem.out.printf(\"%-15s\", name);\t\t\t\tSystem.out.printf(\"%-15s\", date.toString().trim());\t\t\t\tSystem.out.printf(\"%-6s\\n\", price);\t  \t\t\t}\t\t\tconnect.close();\t\t\t} catch(Exception e) {\t\t\tSystem.out.println(\"获取错误\");\t\t\te.printStackTrace();\t\t}\t}}\n课上给的goods表内容\n\n\n\nnumber\nname\nmadeTime\nprice\n\n\n\n\nA001\n奔驰200\n2021-10-10\n340000\n\n\nB002\n宝马320\n2021-05-12\n290000\n\n\nC003\n奥迪A6\n2021-11-21\n350000\n\n\nD004\n联想电脑\n2021-11-25\n7000\n\n\nD005\n大众Tiguan\n2016-05-09\n280000\n\n\n\n","categories":["笔记"],"tags":["java"]},{"title":"2022年河北师范大学程序设计大赛题解","url":"/2023/03/09/2022%E5%B9%B4%E6%B2%B3%E5%8C%97%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%E9%A2%98%E8%A7%A3/","content":" 2022年河北师范大学程序设计大赛题解\n A-百廿师大\n 问题描述：\n2022年10月15日，欣逢河北师范大学120周年华诞，学校将隆重举办系列庆典活动。\n春秋代序，岁月沧桑。1902年顺天府学堂创建于北京，1906年北洋女师范学堂发轫于天津。两支主脉，筚路蓝缕，自强不息，崇尚真理，爱国担当，开时代教育新风。1996年，原河北师范大学、河北师范学院、河北教育学院、河北职业技术师范学院合并，组建新河北师范大学。\n四源汇流，弦歌赓续。学校秉持“怀天下、求真知”校训，坚持“学博为师、德高为范”办学底色，传承红色基因，不忘初心使命。乘高教改革发展长风，抓省部共建和“双一流”建设机遇，围绕建设高水平综合性师范大学目标，致力内涵式高质量发展，肩负人才培养、科学研究、社会服务、文化传承创新、国际交流合作重要使命，努力向党和人民交出满意答卷。\n立德树人，思源怀远。学校120周年庆典，旨在宣示庄严使命，展示办学成就，总结办学经验，共谋未来发展。\n百廿师大，120周年华诞之日距今天数几何？\n输入：\n无输入\n输出:\n输出共一行，包括一个正整数n。n表示今天离河北师范大学120周年校庆的日子还有多少天（不包括今天）。\n例：距离2022年4月1日则为 1 天。\n样例输入：\n//无\n样例输出：\n//无\n 拙见：\n打开屏幕右下角日历去数\n此比赛是2022年3月31日进行的，所以距离2022年10月15日有31 * 3 + 30 * 3 + 15 = 198天\n CODE：\n# include &lt;bits/stdc++.h&gt;using namespace std;int main() {\tcout &lt;&lt; 31 * 3 + 30 * 3 + 15;}\n B-汉堡店的校庆套餐\n 问题描述：\n喜迎校庆，食堂的汉堡店为此推出了许多的组合套餐。一份汉堡一份饮料，配出生活新气象！\n汉堡店一共有n种汉堡，同时也有n种汽水，当你购买购买某种汉堡的时候，只要同时购买对应的饮料（即汉堡和饮料的下标相同），就可以享受到校庆专属优惠！\n喜欢吃汉堡的河小师当然不会错过这个活动，河小师对不同的饮料和汉堡会有不同的满足度，现在河小师该买哪个套餐，才能获得最大的满足度呢？\n给定两个数组，长度均为n。第一个数组给定所有的汉堡满足度，第二个数组给定所有饮料的满足度，河小师可以购买下标相同的饮料和汉堡，问购买第几组套餐，河小师能获得最大满足度。（若存在多组最大满足度套餐，输出下标最小的一组，下标从1开始。）\n输入：\n输入共三行。\n第一行，包括一个正整数n（1 &lt;= n &lt;= 2e5），代表汉堡和饮料的种类数。\n第二行，包括n个数 a[1],a[2],…,a[n] （1 &lt;= a[i] &lt;= 2e5）分别表示每种汉堡的满足度。\n第三行，包括n个数b[1],b[2],…,b[n] (1 &lt;= b[i] &lt;= 2e5)，分别表示每种饮料的满足度。\n输出:\n输出共一行，包括一个正整数。表示选择的套餐的下标。\n样例输入：\n31 2 31 2 1\n样例输出：\n2\n 拙见：\n输出a[i] + b[i]最大的组合套餐的下标。\n CODE：\n# include &lt;bits/stdc++.h&gt;using namespace std;int main() {\tint n,ans,maxV = -1;\tcin &gt;&gt; n;\tvector&lt;int&gt; a(n + 1),b(n + 1);\tfor (int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];\tfor (int i = 1;i &lt;= n;i ++) {        cin &gt;&gt; b[i];        b[i] += a[i];        if (b[i] &gt; maxV) ans = i,maxV = b[i];    }\tcout &lt;&lt; ans;}\n C-多少台阶\n 问题描述：\n享受完美食后，河小师发现食堂门口的台阶贴了喜迎校庆的贴纸，河小师发现，所有阶数为a的倍数或b的倍数的台阶都被贴上了贴纸，好奇的河小师想知道总共有多少台阶上被贴了贴纸。\n一共有n个台阶，所有阶数为a的倍数的台阶或者是b的倍数都被贴上了贴纸，求出一共有多少台阶被贴上了贴纸。\n输入：\n第一行输入一个数t，表示样例数量。(1 &lt;= t &lt;= 1e4)\n输入共t行，每行包括三个正整数n,a,b。（1 &lt;= n &lt;= 2e9，1 &lt;= a &lt;=2e9，1 &lt;= b &lt;= 2e9）\n输出:\n输出共一行，包括一个正整数。被贴上贴纸的台阶总数。\n样例输入：\n310 2 310 3 410 4 5\n样例输出：\n754\n 拙见：\n容斥原理\n能被a染色的台阶数量加上能被b染色的台阶数量，再减去能被a和b的最小公倍数染色的台阶数目\n最小公倍数 = a * b / 最大公约数\n CODE：\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;void solve() {\tll n,a,b;\tcin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\tcout &lt;&lt; n / a + n / b - n / (a * b / __gcd(a,b)) &lt;&lt; endl;}int main() {\tint t;\tcin &gt;&gt; t;\twhile(t --) solve();\treturn 0;}\n D-广场的字符游戏\n 问题描述：\n穿过公教楼，河小师来到了四方广场，这里正在进行校庆游戏，每个人会得到一个由字符’0’和字符’1’组成的字符串，每一次操作可以将其中的任意一个0改成1，也可以将任意一个1改成0，改动之后只要保证不存在任何以101或是010构成的子序列即可完成游戏，获得奖励。河小师怎么样才能以最少的操作次数来解决这个问题呢？\n注：某个序列的子序列是从最初序列选出一部分元素但不破坏他们在原序列中的相对顺序而形成的新序列。例如：110001，可以选出第一个，第三个，第六个字符组成101这个子序列。\n输入：\n输入第一行为数据组数t，表示一共有t组数据。（1 &lt;= t&lt;= 1e3）\n每组数据共一行，包括一个字符串s。（1 &lt;= s.size() &lt;= 1e3）\n输出:\n输出共一行，包括一个正整数。表示解决问题的最少的操作次数。\n样例输入：\n700110010101001001100\n样例输出：\n0011002\n 拙见：\n题中所述101和010其实是1……10……01……0和0……01……10……0这种若干个连续数字的序列。\n因此要使得这个序列满足条件，只有四种形式\n000……000 111……111 1……10……0 0……01……1\n统计0和1的数量，取最小值，这一步是当令序列变成0……0和1……1时，所需要的操作次数。\n此外需要枚举一个0和1的分界点，取最小值，这一步是当令序列变成1……10……0 和0……01……1时，所需要的操作次数。\n CODE：\n# include &lt;bits/stdc++.h&gt;using namespace std;void solve() {\tstring s;\tcin &gt;&gt; s;\tint one = 0,zero = 0;\tfor (int i = 0;i &lt; s.size();i ++)\t\tif (s[i] == '1')\tone ++;\t\telse zero ++;\tint ans = min(one,zero);\tint a = 0,b = 0;\tfor (int i = 0;i &lt; s.size();i ++) {\t//枚举分界点\t\tif (s[i] == '1') a ++;\t\telse b ++;\t\tans = min(ans,b + one - a); //1……10……0形式\t\tans = min(ans,a + zero - b); //0……01……1形式\t}\tcout &lt;&lt; ans &lt;&lt; endl;}int main() {\tint t;cin &gt;&gt; t;\twhile(t --) solve();\treturn 0;}\n E-图书馆借书\n 问题描述：\n获得了奖励，河小师开开心心的去图书馆学习，河小师了解到，图书馆最多能放n本书。一开始图书馆里有满满当当的n本书，河小师在第一天的时候会在早上归还m本书，并在晚上的时候借走一本书，第二天的时候在早上归还m本书，并在晚上的借走两本书… 第i天的时候会在早上归还m本书，并在晚上的时候借走i本书，到第几天的时候，图书馆的书第一次被借完呢？\n图书馆可以存放的书籍数量最多为n本，多余的书河小师会带回宿舍之后再进行归还。\n输入：\n输入共一行，包括两个正整数n,m。（1 ≤ n, m ≤ 1e18）\nn表示图书馆的书籍最大容量，m表示每次的还书数。\n输出:\n输出共一行，包括一个正整数。表示在第几天图书馆的书第一次被借完。\n样例输入：\n5 3\n样例输出：\n5\n提示：\n样例解释：\n第1天应该归还3本但是图书馆满了没有还书，只借了1本书，图书馆还有4本书\n第2天应该归还3本但是图书馆只能容纳1本书，故还1本书，借了2本书，图书馆还有3本书\n第3天应该归还3本但是图书馆只能容纳2本书，故还2本书，借了3本书，图书馆还有2本书\n第4天还3本书，借了4本书，图书馆还有1本书\n第5天还3本书，应该借5本书，但是图书馆只有4本书了，所以借了4本，第一次没有剩余书本。\n 拙见：\n两种情况，n &lt;= m和n &gt; m.\n当n &lt;= m时，每一天早上要还的书都能填满图书馆的容量，所以当第n天时，第一次将所有n本书借走。\n当n &gt; m时，由于每天都要还m本书，所以在前m天中图书馆每天的书只会减少1，在第m天时，图书馆此时剩余n - m本书；在第m天以后，图书馆的书每天会减少1,2,3,……本书，可以得知这是一个公差为1的等差数列。我们的问题是求哪天能第一次将图书馆中的书全部借出，所以从第m + 1天开始，求这个等差数列的前nnn项和SnS_nSn​为多少时，刚好能Sn≥n−mS_n \\ge n - mSn​≥n−m。由于公差d=1d = 1d=1，所以前n项和公式为Sn=n∗(n+1)2S_n = \\frac {n * (n + 1)}   2Sn​=2n∗(n+1)​。由于这个符合单调性，所以可以用二分来查找。最后答案为SnS_nSn​中的n + m。\n关于二分的范围，当n为最大的数据1e18时，大约是x∗(x+1)2=1e18\\frac {x * (x + 1)} 2 = 1e182x∗(x+1)​=1e18，即x2+x=2e18x^2 + x = 2e18x2+x=2e18，所以可以近似为x2=2e18,x=2e9x^2 = 2e18, x = 2e9x2=2e18,x=2e9，因此二分的右边最小为2e92e92e9。\n CODE：\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() {\tll n,m;\tcin &gt;&gt; n &gt;&gt; m;\tif (n &lt;= m) cout &lt;&lt; n &lt;&lt; endl;\telse\t{\t\tll l = -1,r = 2e9 + 10;\t\twhile(l + 1 != r) {\t\t\tll mid = l + r &gt;&gt; 1;\t\t\tif (mid * (mid + 1) / 2 &gt;= n - m)\tr = mid;\t\t\telse l = mid;\t\t}\t\tcout &lt;&lt; r + m &lt;&lt; endl;\t}\treturn 0;}\n F-爱学习的河小师\n 问题描述：\n河小师开始学习啦，他打开一本有趣的算法书，从前往后有n道有趣的题目，每个题目都有一个难度值。因为河小师拥有着勇于挑战的精神，所以做的下一题的难度值和题号都必须高于当前做的题并且河小师只能按题号递增顺序做题（第一题做哪个可以任意选择，若河小师选择做第i题，那么下一个做的题目只能从第i+1个题到第n个题里选择），如何挑选决定去做的题，河小师能做到最多的题目数量呢？\n给定n个题目的难度值，从小到大依次输出河小师选择的题目难度\n如果有多个答案，请输出其中按数值（注：区别于按单个字符的ASCII码值）进行比较的字典序最小的那个答案。\n输入：\n输入共两行。\n第一行包括一个正整数n，表示数组的长度。（0 &lt;= n &lt;= 2e5）\n第二行给定n个正整数a1,a2,a3,…,a[i],…,a[n]，第i题表示题号为i的题目的难度值。（0 &lt;= a[i] &lt;= 1e9）\n输出:\n输出共一行，从小到大依次输出河小师选择的题目难度。\n样例输入：\n样例输入一：92 1 5 3 6 4 8 9 7样例输入二：51 2 8 6 4\n样例输出：\n样例输出一：1 3 4 8 9样例输出二：1 2 4\n提示:\n样例一解释：河小师选择第2题，第4题，第6题，第7题和第8题，故难度依次为1，3，4，8，9.\n 拙见：\n这个题本质上是求最长上升子序列。\n由于数组的长度最大为2e5，所以不能用O(n2)O(n^2)O(n2)的DP来做，应该用贪心+二分来优化，并且在每次记录下dp[i]的长度。二分的部分可以用C++的lower_bound()函数代替。\n至于最小字典序输出，只需要从后往前找，具有相同长度的，就是最小字典序。\n证明，样例二的dp数组为1 2 3 3 3，这个数组是有性质的，比如dp[3],dp[4],dp[5]都为3，那么则说明a[3] ≤\\le≤ a[4] ≤\\le≤ a[5]，可以证明如果a[5] ≥\\ge≥ a[4]的话，那么dp[5]一定比dp[4]要大。\n CODE：\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;int dp[N],f[N],a[N],ans[N],len,n;int main() {\tcin &gt;&gt; n;\tfor (int i = 1;i &lt;= n;i ++)\tcin &gt;&gt; a[i];\tfor (int i = 1;i &lt;= n;i ++) {\t\tint idx;\t\tif (a[i] &gt; f[len]) {\t\t\tf[++ len] = a[i];\t\t\tidx = len;\t\t} else idx = lower_bound(&amp;f[1],&amp;f[len],a[i]) - &amp;f[0];\t\tdp[i] = idx;\t\tlen = max(len,idx);\t\tf[idx] = a[i];\t}\tint cnt = len;\tfor (int i = n;i &gt;= 1;i --)\t\tif (dp[i] == len) \t\t\tans[len --] = a[i];\tfor (int i = 1;i &lt;= cnt;i ++)\t\tcout &lt;&lt; ans[i] &lt;&lt; ' ';\treturn 0;}\n G-真知树上真知果\n 问题描述：\n河小师学的有些渴了，想寻些水果充饥解渴。相传（传说往往虚无缥缈），河北师范大学里有一颗神奇的树，叫真知树。这颗树上有n个节点，在这n个节点里，隐藏着许许多多美味多汁的真知果，当你发现有三个节点两两之间的最短路的长度可以构成一个三角形的时候，你就可以发现一个真知果。（节点可以重复使用，但是三个相同节点只能发现一个真知果）\n聪明的你可以计算一下真知树上有多少真知果吗？\n输入：\n第一行包括一个正整数n, 表示树的节点个数。(1≤n≤1e5)\n接下来n−1行, 每一行三个整数u, v, w 表示节点u 和 v之间有一条边权为w的边。(1≤w≤1e5,1≤u,v≤n)\n输出:\n一行共一个整数, 表示真知果的数量。\n样例输入：\n7 1 2 1 1 3 1 2 4 1 2 5 1 3 6 1 3 7 1\n样例输出：\n8\n 拙见：\n#505. 三角果计数\n将样例画出以后发现，构成三角形的条件在本题中与权值并无关系，只要不是在一条路径上的三个点就可以构成一个三角形。三点之间应直接或间接连接同一节点，我们把这个同一节点称为中心节点。\n可以发现当且仅当这个中心节点的度大于等于3时，这个中心节点可以产生贡献。把这个中心节点的度分成三部分，这三部分的节点数分别为多少，三部分相乘的结果就是这个中心节点的贡献值。\n因此答案就是所有中心节点的贡献值的累加.\n\n如当节点2的贡献值为1 * 1 * 4 = 4.\ndfs时维护一个数组，统计每个节点的度。\n CODE：\n# include &lt;bits/stdc++.h&gt;# define int long longusing namespace std;const int N = 1e5 + 10;vector&lt;int&gt; g[N];int siz[N];int n,ans;void dfs(int u,int v) {    for (int i = 0;i &lt; g[u].size();i ++) {        int t = g[u][i];        if (t != v) {            dfs(t,u);            ans += siz[u] * siz[t] * (n - siz[u] - siz[t] - 1); //三部分相乘            siz[u] += siz[t];        }    }    siz[u] ++; //自身}signed main() {    cin &gt;&gt; n;    for (int i = 1;i &lt; n;i ++) {        int u,v,w;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        g[u].push_back(v);        g[v].push_back(u);    }    dfs(1,0);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}\n H-真知树旁\n 问题描述：\n真知树旁，还有一颗有根树，它也拥有个节点，每个节点有一个权值a[i]。同时我们知道，树上逆序对就是一个由当前节点和它的父节点组成的二元对，同时这两个节点满足子节点的权值小于父节点的权值。\n对于一颗完全m叉树，节点i的子节点很明显就是[m∗(i−1)+2,m∗(i+1)][m*(i−1)+2,m*(i+1)][m∗(i−1)+2,m∗(i+1)]和[1,n][1,n][1,n]交集中的所有正整数。\n现在我们想要知道，在这颗包含n个节点，同时每个节点的权值分别为 的有根树上。河小师抱着怀天下求真知的精神，她想知道若这课树是完全m叉树，其树上逆序对的数量有多少。m=1,2,…,n−1.m=1,2,…,n−1.m=1,2,…,n−1.\n输入：\n第一行包括一个正整数 n , 表示有根树上结点的个数。 (2≤n≤2e5)\n第二行包含 n 个正整数， 分别表示结点的权值(1≤ai≤1e9)\n输出:\n输出一行 n−1 个整数分别表示m=1,2,…,n−1时树上逆序对数\n样例输入：\n55 4 5 4 3\n样例输出：\n3 2 3 3\n 拙见：\n CODE：\n I-夜幕落星河\n 问题描述：\n夜色渐浓，黄昏不住。\n月光触碰夜幕，银河拂过云朵，万千城市共此点亮灯火。\n学习了一天的河小师眼中落满星河，看星星一颗，两颗，三颗，四颗，连成线！\n河小师一共看见了n颗星星，由上文可知，星星之间是可以连线的，它们一共连成了m条星线。当一些星线组成一个环的时候，就会产生奇幻效应，这个环内的所有点之间会产生非常大的吸引力，导致这个环内的所有点之间可以互相传送。环和环之间同样会产生吸引力，若两个环包含的星星数目相同，则两个环之间也可以相互传送。\n河小师想起了牛郎织女的童话故事，织女会随机出现在一个包含k个点的环上，但是织女没有时间等待牛郎慢慢寻找她，天帝只给织女s秒钟的时间和牛郎相见，牛郎从沿着星线从一个星星走到另一个星星需要花费1秒的时间，在环内和环间传送不会花费时间，牛郎特别期待能见到织女，河小师想知道牛郎在哪些星星上出发，能在s秒内见到织女，聪明的同学们，你们能帮帮河小师吗。\n 数据保证只存在简单环，即去掉环内任意一条边这个环就不存在了\n输入：\n第一行共四个正整数n,m,k,s。(2&lt;=n&lt;=1e5,1&lt;=m&lt;=2e5，2&lt;=k&lt;=25,0&lt;=s&lt;=100)\nn表示星星的数目，m表示星线的数目，k表示织女出现的环包含的点数，s为天帝允许织女等待牛郎的时间\n输出:\n输出一个数表示答案\n样例输入：\n11 13 2 11 22 33 44 55 66 77 88 99 1010 112 34 710 11\n样例输出：\n10\n提示：\n样例解释：\n1号星星到达点数为2个点的环需要1秒，2、3、10、11号星星本身就在环内，互相传送不需要花费时间，4、5、6、7、9号星星到达星星数为2的环需要1秒，8号至少需要两秒不符合条件（1种方案是先到达星星4、5、6、7组成的环，再到达2、3组成的环，需要2秒。第二种方案是先到达9号星星，再到达10、11组成的环，因为星星数相同的环之间传送不需要花费时间，不管织女在哪个环上，都可以传送到达）。所以牛郎在10个点的任意一个点出发都可以在1秒之内找到织女\n 拙见：\n CODE：\n","categories":["校赛题解"]},{"title":"方舱隔离记录","url":"/2022/11/21/%E6%96%B9%E8%88%B1%E9%9A%94%E7%A6%BB%E8%AE%B0%E5%BD%95/","content":" 方舱隔离记录\n 11.18\n11.18中午被通知要转运，下午到了石家庄国际会展中心3号舱。我们到的时候这个方舱已经有了一半人，之后陆续来了好几波人，到晚上时这个能容纳800多人的方舱也装满了。\n展厅的灯光很刺眼，声音很嘈杂，幸好带了耳塞。\n 11.19\n这里好像不分昼夜\n\n 11.20\n谁发明的方舱呢？要解决800多人的吃住，只需要一个空旷的场地，再用隔板围上，很像农村里养牲口的圈栏。\n\n晚上突然被通知明天早上可以出舱了，但不能做核酸，做了就走不了。\n可是我的健康码还是阳性红码，为什么可以出舱回学校呢？\n\n","categories":["日记"],"tags":["新冠"]},{"title":"新冠患病记录","url":"/2022/11/19/%E6%96%B0%E5%86%A0%E6%82%A3%E7%97%85%E8%AE%B0%E5%BD%95/","content":" 新冠患病记录\n D1\n无症状\n D2\n无症状\n D3\n傍晚开始嗓子痒，偶尔咳嗽\n睡前有明显不适感\n半夜醒了数次，大约每小时会醒一次，出汗\n D4\n起床体温38℃\n背部肌肉疼痛，腰酸。\n开始咳痰\n中午开始头晕乏力，躺在被子里出了很多汗\n下午呼吸道开始痒\n耳道也开始痒\n持续低烧\n D5\n03:45 嗓子疼醒了，体温38.1\n05:30 嗓子剧痛，体温38.8，鼻塞\n05:53 体温39.2\n06:55 体温39\n07:40 体温38.8\n08:00 开始咳痰流鼻涕，体温38.4\n09:00 体温38.2\n09:30 体温37.9 没食欲\n11:00 体温38.5\n15:30 体温39.3\n16:45 体温39.5\n17:08 开始呕恶，中午没吃饭，所以吐得是胃液\n17:15 体温38.8\n D6\n00:00 体温38.9\n05:00 体温39.4\n06:30 体温38.8 味觉出现异常，疑似丧失一种味觉\n07:41 体温38.7\n09:16 体温38.2\n09:40 体温38\n10:00 体温37.8\n10:35 体温37.4\n11:00 体温37.4\n12:21 体温36.3\n15:30 退烧，咽痛，头痛\n16:00 说话嗓子会痛\n22:30 嗓子剧痛\n D7\n无发热\n04:05 嗓子剧痛疼醒\n07:30 痰逐渐增多\n13:20 咽痛\n D8\n无发热\n咽痛消失\n痰减少\n咳嗽频率上升\n D9\n无发热\n咳嗽频率降低\n D10\n已基本无症状\n早上接到了电话通知，要转运至方舱隔离\n","categories":["日记"],"tags":["新冠"]},{"title":"AcWing 243. 一个简单的整数问题2","url":"/2022/10/28/AcWing%20243.%20%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%982/","content":"\n线段树不是一个算法，而是一个对区间进行修改、维护的工具。\n\n AcWing 243. 一个简单的整数问题2\n题目大意:\n给定一个长度为NNN的数列AAA，以及MMM条指令，每条指令可能是以下两种之一：\n\nC l r d，表示把A[l],A[l+1],…,A[r]A[l],A[l+1], \\ldots,A[r]A[l],A[l+1],…,A[r]都加上ddd。\nQ l r，表示询问数列中第l∼rl \\sim rl∼r个数的和。\n\n对于每个询问，输出一个整数表示答案。\n思路:\n带懒标记的线段树区间和板子题\nCode:\nint n,m;int w[N];struct node{\tint l,r;\tint sum,add;}tr[N * 4];void pushup(int u){\ttr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1|1].sum;}void pushdown(int u){\t//&amp;引用\tauto &amp;root = tr[u],&amp;left = tr[u &lt;&lt; 1],&amp;right = tr[u &lt;&lt; 1|1];\tif (root.add){\t\tleft.add += root.add,left.sum += (left.r - left.l + 1) * root.add;\t\tright.add += root.add,right.sum += (right.r - right.l + 1) * root.add;\t\troot.add = 0;\t}}void build(int u,int l,int r){\tif (l == r)\ttr[u] = {l,r,w[r],0};\telse{\t\ttr[u] = {l,r};\t\tint mid = l + r &gt;&gt; 1;\t\tbuild(u &lt;&lt; 1,l,mid),build(u &lt;&lt; 1|1,mid + 1,r);\t\tpushup(u);\t}}void modify(int u,int l,int r,int d) {\tif (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) {\t\ttr[u].sum += (tr[u].r - tr[u].l + 1) * d;\t\ttr[u].add += d;\t}else {  //分裂\t\tpushdown(u);\t\tint mid = tr[u].l + tr[u].r &gt;&gt; 1;\t\tif (l &lt;= mid)\tmodify(u &lt;&lt; 1,l,r,d);\t\tif (r &gt; mid)\tmodify(u &lt;&lt; 1|1,l,r,d);\t\tpushup(u);\t}}int query(int u,int l,int r) {\tif (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)\treturn tr[u].sum;\t\tpushdown(u);\tint mid = tr[u].l + tr[u].r &gt;&gt; 1;\tint sum = 0;\tif (l &lt;= mid)\tsum = query(u &lt;&lt; 1,l,r);\tif (r &gt; mid)\tsum += query(u &lt;&lt; 1|1,l,r);\treturn sum;}void solve(){\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 1;i &lt;= n;i ++)\tcin &gt;&gt; w[i];\tbuild(1,1,n);\tchar ch;\tint l,r,d;\twhile(m --) {\t\tcin &gt;&gt; ch &gt;&gt; l &gt;&gt; r;\t\tif (ch == 'C') {\t\t\tcin &gt;&gt; d;\t\t\tmodify(1,l,r,d);\t\t} else {\t\t\tcout &lt;&lt; query(1,l,r) &lt;&lt; '\\n';\t\t}\t}}\n","categories":["线段树"],"tags":["线段树"]},{"title":"AcWing 245. 你能回答这些问题吗","url":"/2022/10/28/AcWing%20245.%20%E4%BD%A0%E8%83%BD%E5%9B%9E%E7%AD%94%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97/","content":"\n线段树不是一个算法，而是一个对区间进行修改、维护的工具。\n\n AcWing 245. 你能回答这些问题吗\n题目大意：\n给定长度为NNN的数列AAA，以及MMM条指令，每条指令可能是以下两种之一：\n\n1 x y，查询区间[x,y][x,y][x,y]中的最大连续子段和，即\\underset{x \\le l\\le r\\le y}{max} \\{ \\underset{i=l}  {\\stackrel{r} \\sum}A[i] \\}。\n2 x y，把A[x]A[x]A[x] 改成 yyy。\n\n对于每个查询指令，输出一个整数表示答案。\n思路：\nans=max{tl的最大字段和，tr的最大字段和，跨域区间中点的最大字段和}ans = max\\{ tl的最大字段和，tr的最大字段和，跨域区间中点的最大字段和 \\}\nans=max{tl的最大字段和，tr的最大字段和，跨域区间中点的最大字段和}\ntl，trtl，trtl，tr分为别左右两个子区间，而tl和trtl和trtl和tr的最大字段和递归来求。\n跨越中点的最大字段和 = 以tltltl右端点为右边界向左的最大字段和 + 以trtrtr左端点为左边界向右的最大字段和\n因此线段树结点要维护四个信息：\n\nlmaxlmaxlmax:左端点起的向右的最大字段和\nrmaxrmaxrmax:右端点起的向左的最大字段和\ntmaxtmaxtmax:整个区间的最大字段和\nsumsumsum:区间和\n\nCode:\nstruct node{\tint l,r;\tint sum,lmax,rmax,tmax;}tr[N*4];void pushup(node &amp;u,node &amp;l,node &amp;r){\tu.sum = l.sum + r.sum;\tu.lmax = max(l.lmax,l.sum + r.lmax);\tu.rmax = max(r.rmax,r.sum + l.rmax);\tu.tmax = max(max(l.tmax,r.tmax),l.rmax + r.lmax);}void pushup(int u){\tpushup(tr[u],tr[u &lt;&lt; 1],tr[u &lt;&lt; 1|1]);}void build(int u,int l,int r){\tif (l == r) tr[u] = {l,r,w[r],w[r],w[r],w[r]};\telse{\t\ttr[u] = {l,r};\t\tint mid = l + r &gt;&gt; 1;\t\tbuild(u &lt;&lt; 1,l,mid),build(u &lt;&lt; 1|1,mid + 1,r);\t\tpushup(u);\t}}void modify(int u,int x,int v){\tif (tr[u].l == x &amp;&amp; tr[u].r == x)\ttr[u] = {x,x,v,v,v,v};\telse{\t\tint mid = tr[u].l + tr[u].r &gt;&gt; 1;\t\tif (x &lt;= mid)\tmodify(u &lt;&lt; 1,x,v);\t\telse modify(u &lt;&lt; 1|1,x,v);\t\tpushup(u);\t}}node query(int u,int l,int r){\tif (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)\treturn tr[u];\telse{\t\tint mid = tr[u].l + tr[u].r &gt;&gt; 1;\t\tif (r &lt;= mid)\treturn query(u &lt;&lt; 1,l,r);\t\telse if (l &gt; mid)\treturn query(u &lt;&lt; 1|1,l,r);\t\telse{\t\t\tauto left = query(u &lt;&lt; 1,l,r);\t\t\tauto right = query(u &lt;&lt; 1|1,l,r);\t\t\tnode res;\t\t\tpushup(res,left,right);\t\t\treturn res;\t\t}\t}}void solve(){\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 1;i &lt;= n;i ++)\tcin &gt;&gt; w[i];\tbuild(1,1,n);\tint k,x,y;\twhile(m --){\t\tcin &gt;&gt; k &gt;&gt; x &gt;&gt; y;\t\tif (k == 1){\t\t\tif (x &gt; y)\tswap(x,y);\t\t\tcout &lt;&lt; query(1,x,y).tmax &lt;&lt; '\\n';\t\t}else\t\t\tmodify(1,x,y);\t}}\n","categories":["线段树"],"tags":["线段树"]},{"title":"AcWing 1275. 最大数","url":"/2022/10/28/AcWing%201275.%20%E6%9C%80%E5%A4%A7%E6%95%B0/","content":"\n线段树不是一个算法，而是一个对区间进行修改、维护的工具。\n\n AcWing 1275. 最大数\n题目大意：\n有两种操作，添加和询问。\n\n添加操作：向序列后添加一个数，序列长度变成 n+1n+1n+1；\n询问操作：询问这个序列中最后 LLL 个数中最大的数是多少。\n\n思路：\n线段树板子题，维护区间最大值。\nCode:\nstruct node{\tint l,r;\tint v;}tr[N*4];void build(int u,int l,int r){\t//赋值端点\ttr[u] = {l,r};\t//l == r时为叶子结点\tif (l == r)\treturn;\t\tint mid = l + r &gt;&gt; 1;\t//继续向下建树\tbuild(u &lt;&lt; 1,l,mid);\tbuild(u &lt;&lt; 1 | 1,mid + 1,r);}void pushup(int u){\t//区间最大值\ttr[u].v = max(tr[u &lt;&lt; 1].v,tr[u &lt;&lt; 1|1].v);}int query(int u,int l,int r){\t//如果包含在这个区间\tif (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)\treturn tr[u].v;\t\tint mid = (tr[u].l + tr[u].r) &gt;&gt; 1;\tint v = 0;\tif (l &lt;= mid)\tv = query(u &lt;&lt; 1,l,r);\tif (r &gt; mid)\tv = max(v,query(u &lt;&lt; 1|1,l,r));\treturn v;}void modify(int u,int x,int v){\tif (tr[u].l == x &amp;&amp; tr[u].r == x)\ttr[u].v = v;\telse{\t\tint mid = tr[u].l + tr[u].r &gt;&gt; 1;\t\tif (x &lt;= mid)\tmodify(u &lt;&lt; 1,x,v);\t\telse modify(u &lt;&lt; 1|1,x,v);\t\tpushup(u);\t}}void solve(){\tcin &gt;&gt; m &gt;&gt; p;\tbuild(1,1,m);\tint last = 0,n = 0;\twhile(m --){\t\tchar ch;\t\tint x;\t\tcin &gt;&gt; ch &gt;&gt; x;\t\tif (ch == 'A')\tmodify(1,++n,(x + last) % p);\t\telse{\t\t\tlast = query(1,n - x + 1,n);\t\t\tcout &lt;&lt; last &lt;&lt; endl;\t\t}\t} }","categories":["线段树"],"tags":["线段树"]},{"title":"浅谈KMP算法","url":"/2022/10/03/%E6%B5%85%E8%B0%88KMP%E7%AE%97%E6%B3%95/","content":" 浅谈KMP算法\n KMP是什么？\nKnuth-Morris-Pratt（简称KMP）是一种高效的字符串匹配算法，用来在主字符串中查找**模式字符串（子字符串）的位置，例如在主串\"Hebei Normal University\"中查找模式串\"University\"**的位置。\n这个算法是由D.E.Knuth和V.R.Pratt在1974年构思，同年J.H.Morris也独立设计出该算法，最终三人于1977年联合发表。KMP这个名字则取自三人姓氏首字母。\n KMP有什么用？\n字符串匹配\n朴素的暴力匹配的时间复杂度是O(n∗m)O(n*m)O(n∗m)。\n而KMP可以高效的在O(m+n)O(m + n)O(m+n)的时间复杂度下完成字符串模式匹配，其中mmm和nnn分别是主串和模式串的字符长度。\n KMP怎么用？\n\nKMP的思想核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。\n\n首先要明白三个概念：前缀、后缀以及部分匹配值。\n前缀：字符串中除了最后一个字符以外，其余字符的全部头部顺序组合。\n例如\"abcab\"的前缀为\"a\",“ab”,“abc”,“abca”。\n后缀：字符串中除了第一个字符以外，其余字符的全部尾部顺序组合。\n例如\"abcab\"的后缀为\"b\",“ab”,“cab”,“bacb”。\n部分匹配值：前后缀相同元素长度。\n例如\"abcab\"的最大部分匹配值为2，即\"ab\"。\n 大致思路\n以在S主串\"ababcabcacbab\"中查找P子串\"abcac\"为例。\n\n第一次匹配到的第6个字符时遇到不匹配的情况，此时主串S中已经匹配的字符串为\"ababa\"，字串P中已经匹配的字符串自然也为\"ababa\"。\n\n观察可发现S串中的后三个字符与P串中的前三个字符是相同的。\n\n所以将字串和主串的相同后缀对齐。\n\n如此，便找到了字串P在主串S中出现的位置。\n通过这个样例可以看出，每次滑动的位数是（已匹配字符串长度 - 最大部分匹配值），滑动位数与主串无关，仅通过模式串即可求出，由此引出next数组，即用next数组存储当模式串中第i个字符不匹配时应该移动的位数。\n next数组\nnext数组可谓是KMP算法的核心。\n教科书上给出了一个公式（反正我看不懂\n\n例如求\"ababa\"的next数组\n\n\n\n字符串\nnext数组下标\nnext数组值\n最大部分匹配部分\n\n\n\n\n无\n0\n0\n无\n\n\na\n1\n0\n无\n\n\nab\n2\n0\n无\n\n\naba\n3\n1\na\n\n\nabab\n4\n2\nab\n\n\nababa\n5\n3\naba\n\n\n\n所以说next数组就是求一个字符串的最大部分匹配值\n求next数组的代码：\nfor(int i = 2, j = 0; i &lt;= m; i++){    while(j &amp;&amp; p[i] != p[j+1]) j = next[j];    if(p[i] == p[j+1]) j++;    next[i] = j;}\n上述代码与《数据结构》课本中有所不同，请注意。\n完整KMP代码为：\n#include&lt;iostream&gt;using namespace std;const int N=100010,M=1000010;char q[N],s[M];int ne[N];//保存next数组int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;q+1&gt;&gt;m&gt;&gt;s+1;//下标均从1开始    for(int i=2,j=0;i&lt;=n;i++)    //j表示匹配成功的长度,i表示q数组中的下标,因为q数组的下标是从1开始的,只有1个时,一定为0,所以i从2开始    {        while(j&amp;&amp;q[i]!=q[j+1]) j=ne[j];        //如果不行可以换到next数组        if(q[i]==q[j+1]) j++;        //成功了就加1        ne[i]=j;        //对应其下标    }    //j表示匹配成功的长度,因为刚开始还未开始匹配,所以长度为0    for(int i=1,j=0;i&lt;=m;i++)    {        while(j&amp;&amp;s[i]!=q[j+1]) j=ne[j];        //如果匹配不成功,则换到j对应的next数组中的值        if(s[i]==q[j+1]) j++;        //匹配成功了,那么j就加1,继续后面的匹配        if(j==n)//如果长度等于n了,说明已经完全匹配上去了        {            printf(\"%d \",i-j);            //因为题目中的下标从0开始,所以i-j不用+1;            j=ne[j];            //为了观察其后续是否还能跟S数组后面的数配对成功        }    }    return 0;}\n\n 参考：\nAcWing算法基础课\n","categories":["数据结构"],"tags":["字符串","数据结构"]},{"title":"关于C/C++中的__int128","url":"/2022/10/01/%E5%85%B3%E4%BA%8ECC++%E4%B8%AD%E7%9A%84__int128/","content":" 关于C/C++中的__int128\n\n\n\n数据类型\n占用空间（字节）\n取值范围\n常见数据范围\n\n\n\n\nshort\n2\n(−215∼215−1)(-2^{15}\\sim2^{15}-1)(−215∼215−1)\n/\n\n\nint\n4\n(−231∼231−1)(-2^{31}\\sim2^{31}-1)(−231∼231−1)\n1e9\n\n\nlong\n4\n(−231∼231−1)(-2^{31}\\sim2^{31}-1)(−231∼231−1)\n1e9\n\n\nlong long\n8\n(−263∼263−1)(-2^{63}\\sim2^{63}-1)(−263∼263−1)\n1e18\n\n\n\n我们知道long long最大能表示到大约1e18这个数量级，但如果给的数据&gt;=1e19呢？\n__int128这个数据类型即可解决这个问题。\n __int128是什么？\n__int128是128位的整型，大概是1e38的范围。\n\n __int128有什么用？\n处理大数。\n\n __int128怎么用？\n\n__int128并不是所有的编译器都可以使用，但在Linux系统上是可以编译使用的。因为大部分比赛（蓝桥杯除外）和OJ的评测机都是建立在Linux上，所以做题的时候也可以用。\n\n定义：\n__int128 a;\n输入输出不能使用cin/cout和scanf/printf，需要写一个按位输入输出的函数（快读快写）\n输入函数：\ninline __int128 read(){\t__int128 x = 0,f = 1;char c = getchar();\twhile(!isdigit(c))\tif (c == '-')\tf = -1,c = getchar();\twhile(isdigit(c))\tx = (x &lt;&lt; 1) + (x &lt;&lt; 3) +(c ^ 48),c = getchar();\treturn x * f; }\n输出函数：\ninline void write(__int128 x){\tif (x &lt; 0)\tputchar('-'),x = -x;\tif (x &gt;= 10) write(x / 10);\tputchar(x % 10 + '0');}\n输入输出方法：\na = read();write(a)\n\n__int128类型与int类型一样可以进行算术运算。\n在确定范围超过long long但不超过__int128时，用__int128可以极大的方便运算，但超过1e38时，还是需要打高精度板子。\n","categories":["笔记"],"tags":["C++"]},{"title":"Convex Quadrilateral(ABC266 c)","url":"/2022/09/02/Convex%20Quadrilateral(ABC266%20c)/","content":" Convex Quadrilateral(ABC266 C)\n题目描述：\n给一个四边形坐标，判断它四个内角是不是都小c于180°，是则输出Yes，不是则输出No\n 思路1：\n计算出每个内角的角度，考虑到c++中的asin和atan只能表示[−π2,π2][-\\frac \\pi 2,\\frac \\pi 2][−2π​,2π​]，所以用atan2来进行计算，它能表示[−π,π][-\\pi,\\pi][−π,π].\n得到所有角度以后只要有一个内角大于180°，则输出No\n Code\nvoid solve(){\tPII A,B,C,D;\tcin &gt;&gt; A.x &gt;&gt; A.y;\tcin &gt;&gt; B.x &gt;&gt; B.y;\tcin &gt;&gt; C.x &gt;&gt; C.y;\tcin &gt;&gt; D.x &gt;&gt; D.y;\t\tPDD AB,AD,BC,BA,CB,CD,DC,DA;\tAB = {B.x - A.x,B.y - A.y};\tAD = {D.x - A.x,D.y - A.y};\tBC = {C.x - B.x,C.y - B.y};\tBA = {A.x - B.x,A.y - B.y};\tCB = {B.x - C.x,B.y - C.y};\tCD = {D.x - C.x,D.y - C.y};\tDC = {C.x - D.x,C.y - D.y};\tDA = {A.x - D.x,A.y - D.y};\t\t//AB * AD\tint a = (atan2(AD.y,AD.x) - atan2(AB.y,AB.x)) * 180.0 / PI;\t//BC * BA\tint b = (atan2(BA.y,BA.x) - atan2(BC.y,BC.x)) * 180.0 / PI;\t//CB * CD\tint c = (atan2(CB.y,CB.x) - atan2(CD.y,CD.x)) * 180.0 / PI;\t//DC * DA\tint d = (atan2(DC.y,DC.x) - atan2(DA.y,DA.x)) * 180.0 / PI;\t\ta = (a + 360) % 360;\tb = (b + 360) % 360;\tc = (c + 360) % 360;\td = (d + 360) % 360;\t\tif (a &gt;= 180 || b &gt;= 180 || c &gt;= 180 || d &gt;= 180)\tputs(\"No\");\telse puts(\"Yes\");}\n 思路2：\n思路1的想法很清晰，计算出所有角度再判断，但是这难免有些麻烦。所以我们可以考虑向量运算的性质。\n向量叉乘：\na⃗=(x1,y1),b⃗=(x2,y2)\\vec{a} =(x_1,y_1),\\vec{b} = (x_2,y_2)\na=(x1​,y1​),b=(x2​,y2​)\nk=a⃗×b⃗=∣a∣∣b∣sin⁡θ=x1y2−y1x2k = \\vec a \\times \\vec b = |a| |b|\\sin \\theta = x_1y_2 - y_1x_2\nk=a×b=∣a∣∣b∣sinθ=x1​y2​−y1​x2​\n当k&lt;0k \\lt 0k&lt;0时，sin⁡θ&lt;0\\sin \\theta &lt; 0sinθ&lt;0，那么aaa正旋转到bbb的角度大于180°\n当k&gt;0k \\gt 0k&gt;0时，sin⁡θ&gt;0\\sin\\theta \\gt 0sinθ&gt;0，那么aaa正旋转到bbb的角度小于180°\n利用这个性质我们也可以AC，并且比思路1更直接省事\nint work(int x1,int y1,int x2,int y2){\treturn x1*y2 - y1*x2;}void solve(){\tPII A,B,C,D;\tcin &gt;&gt; A.x &gt;&gt; A.y;\tcin &gt;&gt; B.x &gt;&gt; B.y;\tcin &gt;&gt; C.x &gt;&gt; C.y;\tcin &gt;&gt; D.x &gt;&gt; D.y;\t\tPII AB,AD,BC,BA,CB,CD,DC,DA;\tAB = {B.x - A.x,B.y - A.y};\tAD = {D.x - A.x,D.y - A.y};\tBC = {C.x - B.x,C.y - B.y};\tBA = {A.x - B.x,A.y - B.y};\tCB = {B.x - C.x,B.y - C.y};\tCD = {D.x - C.x,D.y - C.y};\tDC = {C.x - D.x,C.y - D.y};\tDA = {A.x - D.x,A.y - D.y};\t\tif (work(AB.x,AB.y,AD.x,AD.y) &lt; 0)\t{\t\tputs(\"No\");\t\treturn;\t}\t\tif (work(BC.x,BC.y,BA.x,BA.y) &lt; 0)\t{\t\tputs(\"No\");\t\treturn;\t}\t\tif (work(CD.x,CD.y,CB.x,CB.y) &lt; 0)\t{\t\tputs(\"No\");\t\treturn;\t}\t\tif (work(DA.x,DA.y,DC.x,DC.y) &lt; 0)\t{\t\tputs(\"No\");\t\treturn;\t}\t\tputs(\"Yes\");}\n由于本题让我对向量有了更深刻的理解，故记录下来\n","categories":["Atcoder题解"]},{"title":"814(Div.2)A~C","url":"/2022/08/17/814(Div.2)A~C/","content":" Codeforces Round #814 (Div. 2)\n A. Chip Game\n题目大意：\n有一个n*m的棋盘，开局时棋子在左下角，两个玩家轮流移动，每次只能向上或向右移动奇数个格子，最后不能移动的玩家就输了。\n思路：\n由于每个人每次只能移动奇数个格子，我们可以直接移动最大奇数格子数，所以第一个玩家Burenka想赢的话，一定是在第三轮赢得比赛。\n当n和m同为偶数时，最少2轮结束游戏，Tonya赢\n当n和m同为奇数时，最少4轮结束游戏，Tonya赢\n当n和m奇偶性不同时，最少3轮结束游戏，Burenka赢\nAC Code\nvoid solve(){\tint n,m;\tcin &gt;&gt; n &gt;&gt; m;\tstring a = \"Burenka\";\tstring b = \"Tonya\";\tif ((n % 2 == 0 &amp;&amp; m % 2 == 0) || (n % 2 == 1 &amp;&amp; m % 2 == 1))\t\tcout &lt;&lt; b &lt;&lt; endl;\telse cout &lt;&lt; a &lt;&lt; endl;\t}\n B. Mathematical Circus\n题目大意：\n给定两个数n,k，是否能用1~n所有的数组成n2\\frac n 22n​个数对{a,b}，满足(a+k)*b能被4整除。\n如果满足条件则输出YES后输出全部结果，如果不满足条件则输出NO。\n思路1：\n要想满足条件，则一定要有n2\\frac n 22n​个数对。\n分类讨论：\n\n\nk为奇数时，(a+k) * b为偶数*偶数，则能被4整除。\n\n\nk为偶数时\n​\t\t1). k能被4整除：只要a和b其中一个有一个奇数，就不能满足(a + k) * b能被4整除，所以输出NO\n​\t\t2). k不能被4整数：则只要给每个奇数分配一个偶数就可以，b能被4整除时，a为奇数；a+k能被4整除时，b为奇数。\n\n\nAC Code\nvoid solve(){\tint n,k;\tcin &gt;&gt; n &gt;&gt; k;\tif (n == 2 &amp;&amp; k == 0)\t{\t\tputs(\"NO\");\t\treturn;\t}\t\tif (k % 4 == 0)\t{\t\tputs(\"NO\");\t\treturn;\t}\t\tif (k &amp; 1)\t{\t\tputs(\"YES\");\t\tfor (int i = 1;i &lt;= n;i += 2)\t\t\t\tprintf(\"%lld %lld\\n\",i,i + 1);\t}\telse\t{\t\tputs(\"YES\");\t\tfor (int i = 2;i &lt;= n;i += 4)\t\t\tprintf(\"%lld %lld\\n\",i,i - 1);\t\tfor (int i = 3;i &lt;= n;i += 4)\t\t\tprintf(\"%lld %lld\\n\",i,i + 1);\t}}\n思路2：\n要想满足条件，则一定要有n2\\frac n 22n​个数对。\n直接枚举相邻数对{1,2}、{3,4}…{n - 1,n}。\n对于每个数对{x,y}，如果(x + k) * y能被4整除，则添加进答案，否则如果(y + k) * x能被4整除，则添加进答案，如果都不能则不添加。\nAC Code\nvoid solve(){\tint n,k;\tcin &gt;&gt; n &gt;&gt; k;\tvector&lt;PII&gt; ans;\tfor (int i = 1;i &lt;= n;i += 2)\t{\t\tint a = i,b = i + 1;\t\tint x = (a + k) * b,y = (b + k) * a;\t\tif (x % 4 == 0)\tans.push_back({a,b});\t\telse if (y % 4 == 0) ans.push_back({b,a});\t}\t\tif (ans.size() == n / 2)\t{\t\tputs(\"YES\");\t\tfor (auto it:ans)\t\t\tcout &lt;&lt; it.first &lt;&lt; ' ' &lt;&lt; it.second &lt;&lt; '\\n';\t}\telse\t\tputs(\"NO\");}\n C. Fighting Tournament\n题目大意：\n有n名运动员参加比赛，标号为1~n。第i名运动员的实力是a[i] (1 &lt;= a[i] &lt;= n)。每个运动员的实力都是不同的。\n一开始，运动员按标号从小到大排成一列，第一位为1号运动员。\n每一轮比赛，队头的两个人记性格斗，赢的人变成队头，输的人排到队尾。\nq次询问，每次询问给出i和k，问i号运动员在前k次比赛中赢了几场。\n思路：\n当某个人的能量为n时，则无人能赢他，所以我们先找到能量最大的人，记为max。\n所以出现在max后面的人，都没有赢的机会。\n先初始化每个人第一次能赢的场次和最后一次能赢的场次。\n对于每次询问，可以分类讨论：\n选手i在max后面，则能赢的场次为0\n\n如果k小于选手i第一次赢需要耗费的场次，则能赢的场次为0\n如果选手i第一次赢需要耗费的场次为0，则说明他没赢过，最后赢的场次为0\n如果k大于选手i最后一次赢得场次，则他能赢的场次为 最后一次赢-第一次赢 + 1\n如果k小于选手i最后一次硬的场次，则他能赢的场次为 k - 第一次赢 +1\n如果选手i为max，则他能赢的场次为 k - 第一次赢 + 1\n\nAC Code\nvoid solve(){\tint n,q,k;\tint maxx = -INF;\tcin &gt;&gt; n &gt;&gt; q;\t\tvector&lt;int&gt; a(n + 1);\tvector&lt;PII&gt; res(n + 1);\tfor (int i = 1;i &lt;= n;i ++)\t{\t\tcin &gt;&gt; a[i];\t\tif (a[i] == n)\tmaxx = i;\t}\tint mx = a[1],idx = 1,cnt = 1;\tfor (int i = 2;i &lt;= n;i ++)\t{\t\tif (a[i] &lt; mx)\t\t{\t\t\tif (res[idx].second == 0)\tres[idx].first = cnt;\t\t\tres[idx].second = cnt;\t\t}\t\telse\t\t{\t\t\tmx = a[i];\t\t\tidx = i;\t\t\tres[idx].first = cnt;\t\t\tres[idx].second = cnt;\t\t}\t\tcnt ++;\t}\t\twhile(q --)\t{\t\tcin &gt;&gt; idx &gt;&gt; k;\t\tint ans = 0;\t\tbool can = idx &gt; maxx || idx &gt; k + 1 || res[idx].first &gt; k || res[idx].first == 0;\t\tif (!can &amp;&amp; idx == maxx)\tans = k - res[maxx].first + 1;\t\telse if (!can)\t\t{\t\t\tif (k &gt;= res[idx].second) ans = res[idx].second - res[idx].first + 1;\t\t\telse ans = k - res[idx].first + 1;\t\t}\t\tcout &lt;&lt; ans &lt;&lt; endl;\t}}\n","categories":["Codeforces题解"]},{"title":"813(Div.2)A~C","url":"/2022/08/14/813(Div.2)A~C/","content":" Codeforces Round #813 (Div. 2)\n A. Wonderful Permutation\n题目大意：\n给定一个长度为n的序列和一个正整数k。\n在一次操作中，可以对iii和j(1≤i&lt;j≤n)j(1 \\le i\\lt j \\le n)j(1≤i&lt;j≤n)交换pip_ipi​和pjp_jpj​。\n为了使p1+p2+...+pkp_1 + p_2 + ...+p_kp1​+p2​+...+pk​的总和尽可能的小，最少需要多少次操作？\n思路：\n对于一个序列的前kkk项，一定是1+2+...+k1+2+...+k1+2+...+k的总和是最小的。\n所以我们只要统计给定的序列ppp的前kkk项中有几个是大于kkk的即可，对于这些不在1~kkk范围内的元素要进行交换。\nAC Code\nvoid solve(){\tint n,k;\tcin &gt;&gt; n &gt;&gt; k;\tvector&lt;int&gt; a(n + 1);\tmap&lt;int,int&gt; mp;\tfor (int i = 1;i &lt;= n;i ++)\t{\t\tcin &gt;&gt; a[i];\t\tif (i &lt;= k)\tmp[a[i]] = 1; \t}\t\tint ans = 0;\tfor (int i = 1;i &lt;= k;i ++)\t\tif (mp[i] == 0)\tans ++;\t\tcout &lt;&lt; ans &lt;&lt; endl;}\n B. Woeful Permutation\n题目大意：\n给定一个正整数n，要求构造一个permutation使得每一个iii和pip_ipi​的最小公倍数之和最大。\n思路：\n由于相邻的两个数一定互质，而互质数的最小公倍数最大，所以当只要输出两个相邻的数即可。\n当n为奇数时，先输出一个1，然后从i从2开始输出i+1和i\n当n为偶数时，i从1开始输出i+1和i\nAC Code\nvoid solve(){\tint n;\tcin &gt;&gt; n;\t\tif (n &amp; 1)\t{\t\tcout &lt;&lt; 1 &lt;&lt; ' ';\t\tfor (int i = 2;i &lt;= n;i += 2)\t\t\t\t\tcout &lt;&lt; i + 1 &lt;&lt;  ' ' &lt;&lt; i &lt;&lt; ' ';\t}\telse\t\tfor (int i = 1;i &lt;= n;i += 2)\t\t\t\tcout &lt;&lt; i + 1 &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ';\t\tputs(\"\");}\n C. Sort Zero\n题目大意：\n给定一个长度为n的正整数数组。\n在一次操作内：\n1.选择一个整数数xxx\n2.对于数组中所有值等于xxx的元素，全部将其改变成0\n求最少多少次操作可以使得这个数组成为非递减排序\n思路：\n要想成为非递减排序，任意一个0的前面都应该是0，也就是说如果数组中间出现一个0，那么这个0的前面都应该是0才符合要求。\n所以我们要找到的就是最后一个0出现的位置，也就是最后一个a[i] &gt; a[i + 1]的位置idxidxidx。\n然后统计idxidxidx前的有多少个不同的数字，在找到idxidxidx后最后一个被统计过的元素，枚举idxidxidx到最后一个被统计过的元素之间有几个未被统计过的元素。\nAC Code\nvoid solve(){\tint ans = 0;\tint n;\tcin &gt;&gt; n;\tvector&lt;int&gt; cnt;\tvector&lt;int&gt; a(n + 1);\tmap&lt;int,int&gt; mp;\tfor (int i = 1;i &lt;= n;i ++)\t\tcin &gt;&gt; a[i];\t\t\tint idx = n;\tfor (int i = n;i &gt; 1;i --)\t\tif (a[i] &lt; a[i - 1])\tbreak;\t\telse idx = i - 1;\t\tfor (int i = 1;i &lt; idx;i ++)\t\tif (mp[a[i]] == 0)\t\t{\t\t\tans ++;\t\t\tmp[a[i]] = 1;\t\t}\t\tfor (int i = n;i &gt;= idx;i --)\t{\t\tif (mp[a[i]])\t\t{\t\t\tfor (int j = i;j &gt;= idx;j --)\t\t\t\tif (mp[a[j]] == 0)\t\t\t\t{\t\t\t\t\tans ++;\t\t\t\t\tmp[a[j]] = 1;\t\t\t\t}\t\t\tbreak;\t\t}\t}\tcout &lt;&lt; ans &lt;&lt; endl;}\n","categories":["Codeforces题解"]},{"title":"803(Div.2)A~C","url":"/2022/07/07/803(Div.2)A~C/","content":" Codeforces Round #803 (Div. 2)\n A. XOR Mixup\n题目大意：有一个长度为n的数组包含x和n-1个元素，其中x是其他n-1个元素的按位异或，从这个数组中找出x.\n思路：因为n最大为100，所以这题直接暴力枚举就行了.\nvoid solve(){\tint n;\tint res;\tcin &gt;&gt; n;\tfor (int i = 1;i &lt;= n;i ++)\tcin &gt;&gt; a[i];\tfor (int i = 1;i &lt;= n;i ++)\t{\t\tres = a[1];\t\tfor (int j = 2;j &lt;= n;j ++)\t\t{\t\t\tif (j == i)\tcontinue;\t\t\telse\tres = res ^ a[j];\t\t}\t\tif (res == a[i])\t\t{\t\t\tcout &lt;&lt; res &lt;&lt; endl;\t\t\treturn;\t\t}\t}}\n B. Rising Sand\n题目大意：给一组数，定义ans为a[2]~a[n-1]中值大于相邻两个数之和的元素个数。使用一种不限次数的操作选择连续长度为m的序列均加上1。求ans的最大可能值。\n思路：\n分类讨论\n当m == 1时，数组中的每一个数都可以随便加，所以最大值为数组中不相邻的个数，即(n - 1) / 2.\n当m &gt;= 2时，直接暴力模拟即可。\nvoid solve(){\tcin &gt;&gt; n &gt;&gt; k;\tint ans = 0;\t\tfor (int i = 1;i &lt;= n;i ++)\tcin &gt;&gt; a[i];\t\tif (k == 1)\t{\t\tcout &lt;&lt; (n - 1) / 2 &lt;&lt; endl;\t\treturn;\t}\telse\t{\t\tfor (int i = 2;i &lt; n;i ++)\t\t\tif (a[i] &gt; a[i - 1] + a[i + 1])\t\t\t\tans ++;\t}\tcout &lt;&lt; ans &lt;&lt; endl;}\n C. 3SUM Closure\n题目大意：一个长度为n的数组，如果对任意的 1 &lt;= i &lt; j  &lt; k &lt;= n,存在1 &lt;= l &lt;= n，使a[i] + a[j] + a[k] = a[l] 满足，则这个数组是3SUM-closed的。\n判断数组是不是3SUM-closed。\n思路：如果数组有三个正数，选择三个最大的，它们之和必然大于其中任何一个，所以必然不成立。因此，数组最多只能有2个正数。负数同理，最多只能有两个负数。\n0对答案的贡献\n没有0，两正一负\n1个0，一正一负\n2个0，一负或一正\n","categories":["Codeforces题解"]},{"title":"浅谈连通分量","url":"/2022/05/13/%E6%B5%85%E8%B0%88%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","content":" 连通分量\n连通分量编号递减的顺序一定是拓扑序\n 有向图——强连通分量\n将有向图通过缩点的方法，转换成一个有向无环图(DAG)\n缩点：将所有连通分量缩成一个点。\n\n 四条边\n 树枝边：DFS时经过的边，即DFS搜索树上的边\n 前向边：与DFS方向一致，从某个结点指向其某个子孙的边。\n 后向边：与DFS方向相反，从某个结点指向其某个祖先的边。（返祖边）\n 横叉边(x,y)：从某个结点指向搜索树中的另一子树中的某结点的边。\n tarjan算法模板\nvoid tarjan(int u){\tdfn[u] = low[u] = ++ timestamp; //等于时间戳\tstk[ ++ top] = u; //将当前节点加入栈中\tin_stk[u] = true; //记录当前节点是否在栈中\t\t//遍历u所有能到的点\tfor (int i = h[u];~i;i = ne[i])\t{\t\tint j = e[i];\t\t\t\t//如果当前这个点还没有被遍历过\t\tif (!dfn[j])\t\t{\t\t\ttarjan(j);\t\t\t\t\t\t//更新u能到的哪个点的最小值\t\t\tlow[u] = min(low[u],low[j]);\t\t}\t\t\t//如果这个点还在栈中\t\telse if (in_stk[j])\t\t\tlow[u] = min(low[u],dfn[j]);\t}\t\t//如果遍历完后，发现u能到的最前面一个点就是自己\t//则它就是这个强连通分量的最高点\tif (dfn[u] == low[u])\t{\t\tint y;\t\t//强连通分量个数加一\t\t++ scc_cnt;\t\tdo\t\t{\t\t\t//取出栈顶元素\t\t\ty = stk[top --];\t\t\t//标记这个元素已经不在栈中\t\t\tin_stk[y] = false;\t\t\t//标记这个节点属于哪个强连通分量\t\t\tid[y] = scc_cnt;\t\t}while (y != u);//如果到了自己，则退出循环\t}}\n 无向图——双连通分量\n\n","categories":["图论"],"tags":["图论"]},{"title":"浅谈倍增","url":"/2022/05/05/%E6%B5%85%E8%B0%88%E5%80%8D%E5%A2%9E/","content":" 倍增(ST)\n 倍增是什么？\n\n倍增，每次将范围扩大或减少一倍以达到加速的效果\n\n思想引入：如果你想跳到n = 15米远的地方，怎么做？\n\n\n一步一步跳过去（暴力）：显然这是15次\n\n\n2k2^k2k次（倍增）：\n\n设 k = 5，252^525 = 32 &gt; n, k - 1 ,k = 4 （超了）\nk = 4, 242^424 = 16 &gt; n, k - 1,k = 3 （超了)\nk = 3,232^323 = 8 &lt; n，n = n - 8 = 7, k - 1, k = 2（跳)\nk = 2,222^222 = 4 &lt; n，n = n - 4 = 3, k - 1, k = 1（跳）\nk = 1,212^121 = 2 &lt; n，n = n - 2 = 1, k - 1, k = 0（跳）\nk = 0,202^020 = 1 &lt; n，n = n - 1 = 0（跳到了）\n\n即只跳了4次，与暴力做法相比，少了11次。而且数据越大相差的越大，因为暴力是O(n)而倍增是O(lognlog_nlogn​)\n可以发现一个性质，如果跳用1，不跳用0表示，则用二进制表示为1111，这恰好是15。\n所以这就称为二进制转换，比如11用倍增的思想做出来，恰好是1011.\n\n\n 在图论中的应用\n在大多数情况下，图论中的点或边都可以按某种方式排序，如果问题要求的是O(nlognn log_nnlogn​)的时间复杂度，就需要考虑倍增的思想，可以结合dpdpdp的最优子结构和ST表的思想求解。\n 倍增在LCA(最近公共祖先)中的应用\n\nLCA其实就相当于在树上找u到vu到vu到v的最短路，因为找到了最近公共祖先就相当于找到了一条最短路径\n\n首先，要找到uuu和vvv第一个不同祖先不同的位置，然后从这个位置向上走一步就是最近公共祖先。要想找到u,vu,vu,v第一个不同祖先的位置，就要保证u,vu,vu,v在同一深度（这样才能同时向上移一步）\n所以这个过程分为三步：\n1. 预处理找到每个节点深度\n2. 把较深的一点移动到与较浅一点的高度\n3. 两个一起往上移动直到它们的父亲节点相同\n\n先用一个dfs/bfs找到所有的节点深度，用depth数组存下\nfa[i,j]表示从iii开始，向上走2j2^j2j步所能走到的节点。\n 预处理\nvoid bfs(int root){    memset(depth,0x3f,sizeof depth);    depth[0] = 0,depth[root] = 1;    int hh = 0,tt = 0;    q[0] = root;    while(hh &lt;= tt)    {        int t = q[hh ++];        for (int i = h[t];~i;i = ne[i])        {            int j = e[i];            if (depth[j] &gt; depth[t] + 1)            {                depth[j] = depth[t] + 1;                q[ ++ tt] = j;                fa[j][0] = t;                for (int k = 1;k &lt;= 15;k ++)                    fa[j][k] = fa[fa[j][k - 1]][k - 1];            }        }    }}\n 查询\nint lca(int a,int b){    if (depth[a] &lt; depth[b])    swap(a,b);    for (int k = 15;k &gt;= 0;k --)        if (depth[fa[a][k]] &gt;= depth[b])            a = fa[a][k];    if (a == b) return a;    for (int k = 15;k &gt;= 0;k --)        if (fa[a][k] != fa[b][k])        {            a = fa[a][k];            b = fa[b][k];        }    return fa[a][0];}\n","categories":["图论"],"tags":["图论","倍增","LCA"]},{"title":"浅谈二分图","url":"/2022/05/02/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E5%9B%BE/","content":" 二分图\n\n 什么是二分图？\n\n二分图又称二部图，是图论的一种特殊模型。\n节点由两个集合组成，且两个集合内部没有边的图。\n\n\n设G=(U,V)G = (U,V)G=(U,V)是一个无向图，如果顶点UUU可以分割为两个互不相交的子集(A,B)(A,B)(A,B)，并且图中的每条边(i,j)(i,j)(i,j)所关联的两个顶点iii和jjj分别属于这两个不同的顶点集，则称图G为一个二分图。\n 性质\n\n如果两个集合中的点分别染成黑色和白色，可以发现二分图中的每一条边都一定是连接一个黑色点和一个白色点。\n\n 二分图中不存在长度为奇数的环\n这是因为每一条边都是从一个集合走到另一个集合，要想回来必然要走偶数次\n\n 怎么判定一个图是不是二分图呢？\n\n按照定义来说，我们需要知道能否将图中的顶点分成两个满足条件的集合。\n\n染色法：可以通过染色法判定二分图。如果可以通过两种颜色将图染色，使得相同集合中的顶点使用相同的颜色，则为二分图。\n二分图的判定算法主要通过dfs和bfs遍历，如果发现奇数环则不是二分图。\n 二分图的应用\n\n二分图最大匹配\n二分图最大权匹配\n一般图最大匹配\n一般图最大权匹配\n\n\n参考文献：OI Wiki二分图\n","tags":["图论","二分图"]},{"title":"浅谈差分约束","url":"/2022/04/30/%E6%B5%85%E8%B0%88%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/","content":" 差分约束\n 什么是差分约束？\n\n是一种特殊的nnn元一次不等式组，它包含nnn个变量x1,x2,...,xnx_1,x_2,...,x_nx1​,x2​,...,xn​以及mmm个约束条件，每个约束条件是由两个其中的变量做差构成的。\n\n形如xi−xj≤ckx_i - x_j \\le c_kxi​−xj​≤ck​,其中 1≤i,j≤n,i≠j,1≤k≤m1 \\le i,j \\le n, i \\ne j,1 \\le k \\le m1≤i,j≤n,i=j,1≤k≤m并且ckc_kck​是常数（可正可负）。\n约束条件可以变形\nxi−xj≤ck⇔xi≤xj+ckx_i - x_j \\le c_k \\Leftrightarrow x_i \\le x_j + c_k\nxi​−xj​≤ck​⇔xi​≤xj​+ck​\n这就很像图论中的求最短路不等式\ndist[y]≤dist[x]+zdist[y] \\le dist[x] + z\ndist[y]≤dist[x]+z\n因此，我们可以把每个变量xix_ixi​看做图中的一个结点，对于每个约束条件xi−xj≤ckx_i - x_j \\le c_kxi​−xj​≤ck​，看作从结点jjj向结点iii连一条长度为ckc_kck​的有向边。\n如果{a1,a2,...,an}\\lbrace a_1,a_2,...,a_n\\rbrace{a1​,a2​,...,an​}是该差分约束系统的一组解，那么对于任意常数ddd,{a1+d,a2+d,...,an+d}\\lbrace a_1 + d,a_2 + d,...,a_n + d \\rbrace{a1​+d,a2​+d,...,an​+d}显然也是该差分约束系统的一组解，因为这样做差后ddd会被消掉。\n设dist[0]=0dist[0] = 0dist[0]=0并向每一个点连一条权重为0的边，跑单源最短路，若途中存在负环，则给定的差分约束系统无解，否则，xi=dist[i]x_i = dist[i]xi​=dist[i]为该差分约束系统的一组解。\n差分约束最难的地方在于找不等关系\n 有什么用？怎么用？\n 一、求不等式组的可行解\n\n源点需要满足的条件：从源点出发，一定可以走到所有的边\n\n求一组解x1=a1,x2=a2,…,xn=anx_1 = a_1,x_2 = a_2, \\ldots,x_n = a_nx1​=a1​,x2​=a2​,…,xn​=an​,使得所有的约束条件得到满足，否则判断出无解。\n步骤：\n\n先将每个不等式xi≤xj+ckx_i \\le x_j + c_kxi​≤xj​+ck​，转换成一条从xjx_jxj​走到xix_ixi​，长度为ckc_kck​的边。\n找到一个超级源点，使得该源点一定可以走到所以边\n从源点求一遍单源最短路\n\n**结果1：**如果存在负环，则原不等式组一定无解\n**结果2：**如果没有负环,则dist[i]dist[i]dist[i]就是原不等式组的一个可行解\n 二、如何求最大值或者最小值，这里的最值指的是每个变量的最值\n**结论：**如果求的是最小值,则应该求最长路；如果求的是最大值,则应该求最短路\n**问题1：**如何转换xi≤cx_i \\le cxi​≤c，其中ccc是一个常数，此类的不等式\n方法：建立一个超级源点0，然后建立0 -&gt; i的边，长度是c的边即可\n以求xix_ixi​的最大值为例：\n所有从xix_ixi​出发，构成的不等式链\nxi≤xj+c1≤xk+c2+c1≤...≤x0+c1+c2+...+cm(x0=0)x_i \\le x_j + c_1 \\le x_k + c_2 + c_1 \\le ... \\le x_0 + c_1 + c_2 + ...  + c_m (x_0 = 0)\nxi​≤xj​+c1​≤xk​+c2​+c1​≤...≤x0​+c1​+c2​+...+cm​(x0​=0)\n所计算出的上界，最终xix_ixi​的最大值等于所有上界的最小值。\n \n\n如这个例子中，x1x_1x1​的最大值为5\n转换为图论问题，就是求dist[i]dist[i]dist[i]的最小值，即最短路求解\n求xix_ixi​的最小值时则相反，通过不等式链计算出下界，最终在所有下界中取最大值\n转换为图论问题就是求dist[i]dist[i]dist[i]得最大值，即最长路求解\n参考文献：\nOI Wiki差分约束\n","categories":["图论"]},{"title":"浅谈01分数规划","url":"/2022/04/30/%E6%B5%85%E8%B0%8801%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","content":" 01分数规划\n 什么是01分数规划？\n分数规划用来求一个分式的极值。\n给出aia_iai​和bib_ibi​，求一组wiw_iwi​ ∈ {0，1}，最小化或最大化\n∑i=1nai×wi∑i=1nbi×wi\\frac{\\sum_{i=1}^n a_i \\times w_i}{\\sum_{i=1}^n b_i \\times w_i} \n∑i=1n​bi​×wi​∑i=1n​ai​×wi​​\n另一种描述：每种物品有两个权值aaa和bbb,选出若干个物品使得∑a∑b\\frac{\\sum a}{\\sum b}∑b∑a​ 最大/最小。\n在图论问题（求负环、最小生成树和最短路）中类似于∑a∑b\\frac{\\sum a}{\\sum b}∑b∑a​这样形式的题，称为01分数规划\n 有什么用？\n做图论题会用到\n 怎么用？\n二分\n例如 观光奶牛 这道题\n判断图中是否存在环CCC，使得∑a∑b&gt;mid\\frac{\\sum a}{\\sum b} \\gt mid∑b∑a​&gt;mid\n∑a∑b&gt;mid⇔∑a&gt;mid×∑b⇔∑a−mid×∑b&gt;0\\frac{\\sum a}{\\sum b} \\gt mid \\Leftrightarrow \\sum a \\gt mid \\times \\sum b \\Leftrightarrow \\sum a - mid \\times \\sum b \\gt 0∑b∑a​&gt;mid⇔∑a&gt;mid×∑b⇔∑a−mid×∑b&gt;0\n所以公式可以转换为:∑(ai−mid×bi)&gt;0)⇔图中是否存在正环\\sum(a_i - mid \\times b_i) \\gt 0) \\Leftrightarrow 图中是否存在正环∑(ai​−mid×bi​)&gt;0)⇔图中是否存在正环\n01分数规划思路\n1. 二分出一个常值2. 整理不等式，重新定义点权/边权3. 做图论算法\n参考文献：\nOI Wiki分数规划\n","categories":["图论"]}]